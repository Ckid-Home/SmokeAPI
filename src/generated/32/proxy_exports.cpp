// Auto-generated source file
#include <cstring>
#include <dlfcn.h>
#include <mutex>

#include <polyhook2/MemProtector.hpp>

#include <koalabox/lib.hpp>
#include <koalabox/logger.hpp>
#include <koalabox/util.hpp>

#include "proxy_exports.hpp"

#define EXPORT extern "C" __attribute__((visibility("default"))) __attribute__((naked))

EXPORT void CAddAppDependencyResult_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CAddAppDependencyResult_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CAddUGCDependencyResult_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CAddUGCDependencyResult_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CAssociateWithClanResult_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CAssociateWithClanResult_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CChangeNumOpenSlotsCallback_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CChangeNumOpenSlotsCallback_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CCheckFileSignature_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CCheckFileSignature_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CClanOfficerListResponse_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CClanOfficerListResponse_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CComputeNewPlayerCompatibilityResult_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CComputeNewPlayerCompatibilityResult_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CCreateBeaconCallback_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CCreateBeaconCallback_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CCreateItemResult_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CCreateItemResult_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CDeleteItemResult_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CDeleteItemResult_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CDurationControl_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CDurationControl_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CEncryptedAppTicketResponse_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CEncryptedAppTicketResponse_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CFileDetailsResult_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CFileDetailsResult_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CFriendsEnumerateFollowingList_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CFriendsEnumerateFollowingList_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CFriendsGetFollowerCount_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CFriendsGetFollowerCount_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CFriendsIsFollowing_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CFriendsIsFollowing_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CGSReputation_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CGSReputation_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CGSStatsReceived_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CGSStatsReceived_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CGSStatsStored_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CGSStatsStored_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CGetAppDependenciesResult_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CGetAppDependenciesResult_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CGetOPFSettingsResult_t_RemoveCallback() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CGetOPFSettingsResult_t_SetCallback() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CGetUserItemVoteResult_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CGetUserItemVoteResult_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CGlobalAchievementPercentagesReady_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CGlobalAchievementPercentagesReady_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CGlobalStatsReceived_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CGlobalStatsReceived_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CHTML_BrowserReady_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CHTML_BrowserReady_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CJoinClanChatRoomCompletionResult_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CJoinClanChatRoomCompletionResult_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CJoinPartyCallback_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CJoinPartyCallback_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CLeaderboardFindResult_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CLeaderboardFindResult_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CLeaderboardScoreUploaded_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CLeaderboardScoreUploaded_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CLeaderboardScoresDownloaded_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CLeaderboardScoresDownloaded_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CLeaderboardUGCSet_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CLeaderboardUGCSet_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CLobbyCreated_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CLobbyCreated_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CLobbyEnter_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CLobbyEnter_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CLobbyMatchList_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CLobbyMatchList_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CMarketEligibilityResponse_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CMarketEligibilityResponse_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CNumberOfCurrentPlayers_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CNumberOfCurrentPlayers_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CPublisherOwnedAppDataReady_t_RemoveCallback() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CPublisherOwnedAppDataReady_t_SetCallback() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CRemoteStorageDeletePublishedFileResult_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CRemoteStorageDeletePublishedFileResult_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CRemoteStorageDownloadUGCResult_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CRemoteStorageDownloadUGCResult_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CRemoteStorageEnumeratePublishedFilesByUserActionResult_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CRemoteStorageEnumeratePublishedFilesByUserActionResult_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CRemoteStorageEnumerateUserPublishedFilesResult_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CRemoteStorageEnumerateUserPublishedFilesResult_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CRemoteStorageEnumerateUserSubscribedFilesResult_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CRemoteStorageEnumerateUserSubscribedFilesResult_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CRemoteStorageEnumerateWorkshopFilesResult_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CRemoteStorageEnumerateWorkshopFilesResult_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CRemoteStorageFileReadAsyncComplete_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CRemoteStorageFileReadAsyncComplete_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CRemoteStorageFileShareResult_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CRemoteStorageFileShareResult_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CRemoteStorageFileWriteAsyncComplete_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CRemoteStorageFileWriteAsyncComplete_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CRemoteStorageGetPublishedFileDetailsResult_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CRemoteStorageGetPublishedFileDetailsResult_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CRemoteStorageGetPublishedItemVoteDetailsResult_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CRemoteStorageGetPublishedItemVoteDetailsResult_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CRemoteStoragePublishFileProgress_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CRemoteStoragePublishFileProgress_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CRemoteStorageSetUserPublishedFileActionResult_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CRemoteStorageSetUserPublishedFileActionResult_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CRemoteStorageSubscribePublishedFileResult_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CRemoteStorageSubscribePublishedFileResult_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CRemoteStorageUnsubscribePublishedFileResult_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CRemoteStorageUnsubscribePublishedFileResult_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CRemoteStorageUpdatePublishedFileResult_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CRemoteStorageUpdatePublishedFileResult_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CRemoteStorageUpdateUserPublishedItemVoteResult_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CRemoteStorageUpdateUserPublishedItemVoteResult_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CRemoveAppDependencyResult_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CRemoveAppDependencyResult_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CRemoveUGCDependencyResult_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CRemoveUGCDependencyResult_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CSetPersonaNameResponse_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CSetPersonaNameResponse_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CSetUserItemVoteResult_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CSetUserItemVoteResult_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CStartPlaytimeTrackingResult_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CStartPlaytimeTrackingResult_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CSteamInventoryEligiblePromoItemDefIDs_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CSteamInventoryEligiblePromoItemDefIDs_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CSteamInventoryRequestPricesResult_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CSteamInventoryRequestPricesResult_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CSteamInventoryStartPurchaseResult_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CSteamInventoryStartPurchaseResult_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CSteamUGCQueryCompleted_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CSteamUGCQueryCompleted_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CStopPlaytimeTrackingResult_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CStopPlaytimeTrackingResult_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CStoreAuthURLResponse_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CStoreAuthURLResponse_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CSubmitItemUpdateResult_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CSubmitItemUpdateResult_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CUserFavoriteItemsListChanged_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CUserFavoriteItemsListChanged_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CUserStatsReceived_t_RemoveCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CUserStatsReceived_t_RemoveCallback() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CUserStatsReceived_t_SetCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void CUserStatsReceived_t_SetCallback() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void GetHSteamPipe() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void GetHSteamUser() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void ISteamApps_BIsCybercafe() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void ISteamApps_BIsLowViolence() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void ISteamApps_BIsSubscribed() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void ISteamApps_BIsSubscribedApp() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void ISteamApps_GetAvailableGameLanguages() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void ISteamApps_GetCurrentGameLanguage() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void ISteamClient_SetLocalIPBinding() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void ISteamGameServer_BLoggedOn() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void ISteamGameServer_BSecure() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void ISteamGameServer_BUpdateUserData() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void ISteamGameServer_CreateUnauthenticatedUserConnection() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void ISteamGameServer_GetSteamID() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void ISteamGameServer_SendUserConnectAndAuthenticate() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void ISteamGameServer_SendUserDisconnect() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void ISteamGameServer_SetGameType() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void ISteamGameServer_SetServerType() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void ISteamGameServer_UpdateSpectatorPort() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void ISteamGameServer_UpdateStatus() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void ISteamMasterServerUpdater_AddMasterServer() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void ISteamMasterServerUpdater_ClearAllKeyValues() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void ISteamMasterServerUpdater_ForceHeartbeat() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void ISteamMasterServerUpdater_GetMasterServerAddress() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void ISteamMasterServerUpdater_GetNextOutgoingPacket() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void ISteamMasterServerUpdater_GetNumMasterServers() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void ISteamMasterServerUpdater_HandleIncomingPacket() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void ISteamMasterServerUpdater_NotifyShutdown() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void ISteamMasterServerUpdater_RemoveMasterServer() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void ISteamMasterServerUpdater_SetActive() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void ISteamMasterServerUpdater_SetBasicServerData() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void ISteamMasterServerUpdater_SetHeartbeatInterval() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void ISteamMasterServerUpdater_SetKeyValue() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void ISteamMasterServerUpdater_WasRestartRequested() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void ISteamUser_BLoggedOn() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void ISteamUser_InitiateGameConnection() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void ISteamUser_TerminateGameConnection() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void ISteamUtils_GetAppID() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_GetHSteamPipe() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_GetHSteamUser() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_GetSteamInstallPath() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamAppList_GetAppBuildId() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamAppList_GetAppInstallDir() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamAppList_GetAppName() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamAppList_GetInstalledApps() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamAppList_GetNumInstalledApps() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamApps_BGetDLCDataByIndex() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamApps_BIsAppInstalled() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamApps_BIsCybercafe() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamApps_BIsDlcInstalled() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamApps_BIsLowViolence() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamApps_BIsSubscribed() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamApps_BIsSubscribedApp() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamApps_BIsSubscribedFromFamilySharing() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamApps_BIsSubscribedFromFreeWeekend() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamApps_BIsTimedTrial() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamApps_BIsVACBanned() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamApps_GetAppBuildId() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamApps_GetAppInstallDir() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamApps_GetAppOwner() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamApps_GetAvailableGameLanguages() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamApps_GetBetaInfo() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamApps_GetCurrentBetaName() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamApps_GetCurrentGameLanguage() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamApps_GetDLCCount() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamApps_GetDlcDownloadProgress() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamApps_GetEarliestPurchaseUnixTime() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamApps_GetFileDetails() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamApps_GetInstalledDepots() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamApps_GetLaunchCommandLine() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamApps_GetLaunchQueryParam() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamApps_GetNumBetas() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamApps_GetPublisherOwnedAppData() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamApps_InstallDLC() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamApps_MarkContentCorrupt() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamApps_RequestAllProofOfPurchaseKeys() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamApps_RequestAppProofOfPurchaseKey() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamApps_RequestPublisherOwnedAppData() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamApps_SetActiveBeta() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamApps_SetDlcContext() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamApps_UninstallDLC() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamClient_BReleaseSteamPipe() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamClient_BShutdownIfAllPipesClosed() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamClient_ConnectToGlobalUser() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamClient_CreateLocalUser() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamClient_CreateSteamPipe() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamClient_GetIPCCallCount() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamClient_GetISteamAppList() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamClient_GetISteamApps() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamClient_GetISteamController() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamClient_GetISteamFriends() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamClient_GetISteamGameSearch() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamClient_GetISteamGameServer() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamClient_GetISteamGameServerStats() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamClient_GetISteamGenericInterface() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamClient_GetISteamHTMLSurface() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamClient_GetISteamHTTP() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamClient_GetISteamInput() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamClient_GetISteamInventory() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamClient_GetISteamMatchmaking() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamClient_GetISteamMatchmakingServers() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamClient_GetISteamMusic() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamClient_GetISteamMusicRemote() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamClient_GetISteamNetworking() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamClient_GetISteamParentalSettings() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamClient_GetISteamParties() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamClient_GetISteamRemotePlay() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamClient_GetISteamRemoteStorage() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamClient_GetISteamScreenshots() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamClient_GetISteamUGC() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamClient_GetISteamUnifiedMessages() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamClient_GetISteamUser() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamClient_GetISteamUserStats() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamClient_GetISteamUtils() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamClient_GetISteamVideo() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamClient_ReleaseUser() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamClient_Remove_SteamAPI_CPostAPIResultInProcess() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamClient_RunFrame() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamClient_SetLocalIPBinding() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamClient_SetWarningMessageHook() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamClient_Set_SteamAPI_CCheckCallbackRegisteredInProcess() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamClient_Set_SteamAPI_CPostAPIResultInProcess() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamController_ActivateActionSet() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamController_ActivateActionSetLayer() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamController_DeactivateActionSetLayer() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamController_DeactivateAllActionSetLayers() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamController_GetActionOriginFromXboxOrigin() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamController_GetActionSetHandle() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamController_GetActiveActionSetLayers() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamController_GetAnalogActionData() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamController_GetAnalogActionHandle() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamController_GetAnalogActionOrigins() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamController_GetConnectedControllers() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamController_GetControllerBindingRevision() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamController_GetControllerForGamepadIndex() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamController_GetControllerState() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamController_GetCurrentActionSet() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamController_GetDigitalActionData() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamController_GetDigitalActionHandle() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamController_GetDigitalActionOrigins() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamController_GetGamepadIndexForController() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamController_GetGlyphForActionOrigin() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamController_GetGlyphForXboxOrigin() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamController_GetInputTypeForHandle() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamController_GetMotionData() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamController_GetStringForActionOrigin() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamController_GetStringForXboxOrigin() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamController_Init() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamController_RunFrame() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamController_SetLEDColor() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamController_SetOverrideMode() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamController_ShowAnalogActionOrigins() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamController_ShowBindingPanel() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamController_ShowDigitalActionOrigins() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamController_Shutdown() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamController_StopAnalogActionMomentum() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamController_TranslateActionOrigin() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamController_TriggerHapticPulse() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamController_TriggerRepeatedHapticPulse() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamController_TriggerVibration() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_ActivateGameOverlay() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_ActivateGameOverlayInviteDialog() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_ActivateGameOverlayInviteDialogConnectString() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_ActivateGameOverlayRemotePlayTogetherInviteDialog() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_ActivateGameOverlayToStore() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_ActivateGameOverlayToUser() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_ActivateGameOverlayToWebPage() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_BHasEquippedProfileItem() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_ClearRichPresence() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_CloseClanChatWindowInSteam() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_DownloadClanActivityCounts() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_EnumerateFollowingList() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_GetChatMemberByIndex() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_GetClanActivityCounts() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_GetClanByIndex() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_GetClanChatMemberCount() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_GetClanChatMessage() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_GetClanCount() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_GetClanName() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_GetClanOfficerByIndex() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_GetClanOfficerCount() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_GetClanOwner() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_GetClanTag() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_GetCoplayFriend() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_GetCoplayFriendCount() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_GetFollowerCount() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_GetFriendByIndex() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_GetFriendCoplayGame() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_GetFriendCoplayTime() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_GetFriendCount() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_GetFriendCountFromSource() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_GetFriendFromSourceByIndex() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_GetFriendGamePlayed() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_GetFriendMessage() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_GetFriendPersonaName() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_GetFriendPersonaNameHistory() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_GetFriendPersonaState() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_GetFriendRelationship() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_GetFriendRichPresence() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_GetFriendRichPresenceKeyByIndex() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_GetFriendRichPresenceKeyCount() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_GetFriendSteamLevel() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_GetFriendsGroupCount() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_GetFriendsGroupIDByIndex() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_GetFriendsGroupMembersCount() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_GetFriendsGroupMembersList() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_GetFriendsGroupName() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_GetLargeFriendAvatar() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_GetMediumFriendAvatar() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_GetNumChatsWithUnreadPriorityMessages() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_GetPersonaName() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_GetPersonaState() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_GetPlayerNickname() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_GetProfileItemPropertyString() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_GetProfileItemPropertyUint() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_GetSmallFriendAvatar() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_GetUserRestrictions() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_HasFriend() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_InviteUserToGame() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_IsClanChatAdmin() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_IsClanChatWindowOpenInSteam() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_IsClanOfficialGameGroup() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_IsClanPublic() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_IsFollowing() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_IsUserInSource() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_JoinClanChatRoom() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_LeaveClanChatRoom() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_OpenClanChatWindowInSteam() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_RegisterProtocolInOverlayBrowser() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_ReplyToFriendMessage() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_RequestClanOfficerList() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_RequestEquippedProfileItems() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_RequestFriendRichPresence() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_RequestUserInformation() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_SendClanChatMessage() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_SetInGameVoiceSpeaking() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_SetListenForFriendsMessages() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_SetPersonaName() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_SetPlayedWith() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamFriends_SetRichPresence() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameSearch_AcceptGame() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameSearch_AddGameSearchParams() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameSearch_CancelRequestPlayersForGame() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameSearch_DeclineGame() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameSearch_EndGame() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameSearch_EndGameSearch() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameSearch_HostConfirmGameStart() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameSearch_RequestPlayersForGame() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameSearch_RetrieveConnectionDetails() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameSearch_SearchForGameSolo() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameSearch_SearchForGameWithLobby() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameSearch_SetConnectionDetails() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameSearch_SetGameHostParams() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameSearch_SubmitPlayerResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameServerStats_ClearUserAchievement() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameServerStats_GetUserAchievement() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameServerStats_GetUserStat() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameServerStats_GetUserStat0() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameServerStats_GetUserStatFloat() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameServerStats_GetUserStatInt32() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameServerStats_RequestUserStats() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameServerStats_SetUserAchievement() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameServerStats_SetUserStat() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameServerStats_SetUserStat0() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameServerStats_SetUserStatFloat() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameServerStats_SetUserStatInt32() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameServerStats_StoreUserStats() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameServerStats_UpdateUserAvgRateStat() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameServer_AssociateWithClan() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameServer_BLoggedOn() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameServer_BSecure() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameServer_BUpdateUserData() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameServer_BeginAuthSession() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameServer_CancelAuthTicket() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameServer_ClearAllKeyValues() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameServer_ComputeNewPlayerCompatibility() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameServer_CreateUnauthenticatedUserConnection() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameServer_EnableHeartbeats() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameServer_EndAuthSession() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameServer_ForceHeartbeat() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameServer_GetAuthSessionTicket() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameServer_GetGameplayStats() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameServer_GetNextOutgoingPacket() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameServer_GetPublicIP() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameServer_GetServerReputation() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameServer_GetSteamID() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameServer_HandleIncomingPacket() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameServer_InitGameServer() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameServer_LogOff() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameServer_LogOn() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameServer_LogOnAnonymous() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameServer_RequestUserGroupStatus() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameServer_SendUserConnectAndAuthenticate() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameServer_SendUserConnectAndAuthenticate_DEPRECATED() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameServer_SendUserDisconnect() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameServer_SendUserDisconnect_DEPRECATED() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameServer_SetAdvertiseServerActive() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameServer_SetBotPlayerCount() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameServer_SetDedicatedServer() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameServer_SetGameData() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameServer_SetGameDescription() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameServer_SetGameTags() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameServer_SetHeartbeatInterval() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameServer_SetKeyValue() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameServer_SetMapName() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameServer_SetMaxPlayerCount() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameServer_SetModDir() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameServer_SetPasswordProtected() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameServer_SetProduct() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameServer_SetRegion() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameServer_SetServerName() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameServer_SetSpectatorPort() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameServer_SetSpectatorServerName() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameServer_UserHasLicenseForApp() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamGameServer_WasRestartRequested() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_AddHeader() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_AllowStartRequest() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_CopyToClipboard() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_CreateBrowser() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_DestructISteamHTMLSurface() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_ExecuteJavascript() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_FileLoadDialogResponse() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_Find() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_GetLinkAtPosition() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_GoBack() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_GoForward() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_Init() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_JSDialogResponse() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_KeyChar() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_KeyDown() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_KeyUp() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_LoadURL() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_MouseDoubleClick() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_MouseDown() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_MouseMove() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_MouseUp() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_MouseWheel() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_OpenDeveloperTools() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_PasteFromClipboard() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_Reload() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_RemoveBrowser() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_SetBackgroundMode() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_SetCookie() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_SetDPIScalingFactor() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_SetHorizontalScroll() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_SetKeyFocus() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_SetPageScaleFactor() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_SetSize() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_SetVerticalScroll() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_Shutdown() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_StopFind() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_StopLoad() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamHTMLSurface_ViewSource() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamHTTP_CreateCookieContainer() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamHTTP_CreateHTTPRequest() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamHTTP_DeferHTTPRequest() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamHTTP_GetHTTPDownloadProgressPct() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamHTTP_GetHTTPRequestWasTimedOut() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamHTTP_GetHTTPResponseBodyData() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamHTTP_GetHTTPResponseBodySize() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamHTTP_GetHTTPResponseHeaderSize() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamHTTP_GetHTTPResponseHeaderValue() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamHTTP_GetHTTPStreamingResponseBodyData() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamHTTP_PrioritizeHTTPRequest() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamHTTP_ReleaseCookieContainer() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamHTTP_ReleaseHTTPRequest() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamHTTP_SendHTTPRequest() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamHTTP_SendHTTPRequestAndStreamResponse() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamHTTP_SetCookie() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamHTTP_SetHTTPRequestAbsoluteTimeoutMS() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamHTTP_SetHTTPRequestContextValue() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamHTTP_SetHTTPRequestCookieContainer() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamHTTP_SetHTTPRequestGetOrPostParameter() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamHTTP_SetHTTPRequestHeaderValue() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamHTTP_SetHTTPRequestNetworkActivityTimeout() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamHTTP_SetHTTPRequestRawPostBody() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamHTTP_SetHTTPRequestRequiresVerifiedCertificate() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamHTTP_SetHTTPRequestUserAgentInfo() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInput_ActivateActionSet() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInput_ActivateActionSetLayer() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInput_BNewDataAvailable() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInput_BWaitForData() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInput_DeactivateActionSetLayer() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInput_DeactivateAllActionSetLayers() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInput_EnableActionEventCallbacks() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInput_EnableDeviceCallbacks() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInput_GetActionOriginFromXboxOrigin() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInput_GetActionSetHandle() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInput_GetActiveActionSetLayers() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInput_GetAnalogActionData() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInput_GetAnalogActionHandle() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInput_GetAnalogActionOrigins() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInput_GetConnectedControllers() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInput_GetControllerForGamepadIndex() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInput_GetCurrentActionSet() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInput_GetDeviceBindingRevision() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInput_GetDigitalActionData() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInput_GetDigitalActionHandle() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInput_GetDigitalActionOrigins() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInput_GetGamepadIndexForController() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInput_GetGlyphForActionOrigin() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInput_GetGlyphForActionOrigin_Legacy() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInput_GetGlyphForXboxOrigin() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInput_GetGlyphPNGForActionOrigin() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInput_GetGlyphSVGForActionOrigin() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInput_GetInputTypeForHandle() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInput_GetMotionData() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInput_GetRemotePlaySessionID() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInput_GetSessionInputConfigurationSettings() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInput_GetStringForActionOrigin() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInput_GetStringForAnalogActionName() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInput_GetStringForDigitalActionName() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInput_GetStringForXboxOrigin() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInput_Init() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInput_Legacy_TriggerHapticPulse() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInput_Legacy_TriggerRepeatedHapticPulse() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInput_RunFrame() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInput_SetDualSenseTriggerEffect() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInput_SetInputActionManifestFilePath() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInput_SetLEDColor() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInput_ShowBindingPanel() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInput_Shutdown() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInput_StopAnalogActionMomentum() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInput_TranslateActionOrigin() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInput_TriggerHapticPulse() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInput_TriggerRepeatedHapticPulse() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInput_TriggerSimpleHapticEvent() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInput_TriggerVibration() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInput_TriggerVibrationExtended() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInventory_AddPromoItem() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInventory_AddPromoItems() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInventory_CheckResultSteamID() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInventory_ConsumeItem() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInventory_DeserializeResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInventory_DestroyResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInventory_ExchangeItems() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInventory_GenerateItems() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInventory_GetAllItems() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInventory_GetEligiblePromoItemDefinitionIDs() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInventory_GetItemDefinitionIDs() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInventory_GetItemDefinitionProperty() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInventory_GetItemPrice() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInventory_GetItemsByID() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInventory_GetItemsWithPrices() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInventory_GetNumItemsWithPrices() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInventory_GetResultItemProperty() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInventory_GetResultItems() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInventory_GetResultStatus() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInventory_GetResultTimestamp() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInventory_GrantPromoItems() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInventory_InspectItem() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInventory_LoadItemDefinitions() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInventory_RemoveProperty() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInventory_RequestEligiblePromoItemDefinitionsIDs() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInventory_RequestPrices() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInventory_SendItemDropHeartbeat() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInventory_SerializeResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInventory_SetProperty() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInventory_SetProperty0() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInventory_SetProperty1() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInventory_SetProperty2() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInventory_SetPropertyBool() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInventory_SetPropertyFloat() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInventory_SetPropertyInt64() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInventory_SetPropertyString() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInventory_StartPurchase() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInventory_StartUpdateProperties() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInventory_SubmitUpdateProperties() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInventory_TradeItems() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInventory_TransferItemQuantity() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamInventory_TriggerItemDrop() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmakingPingResponse_ServerFailedToRespond() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmakingPingResponse_ServerResponded() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmakingPlayersResponse_AddPlayerToList() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmakingPlayersResponse_PlayersFailedToRespond() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmakingPlayersResponse_PlayersRefreshComplete() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmakingRulesResponse_RulesFailedToRespond() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmakingRulesResponse_RulesRefreshComplete() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmakingRulesResponse_RulesResponded() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmakingServerListResponse_RefreshComplete() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmakingServerListResponse_ServerFailedToRespond() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmakingServerListResponse_ServerResponded() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmakingServers_CancelQuery() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmakingServers_CancelServerQuery() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmakingServers_GetServerCount() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmakingServers_GetServerDetails() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmakingServers_IsRefreshing() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmakingServers_PingServer() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmakingServers_PlayerDetails() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmakingServers_RefreshQuery() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmakingServers_RefreshServer() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmakingServers_ReleaseRequest() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmakingServers_RequestFavoritesServerList() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmakingServers_RequestFriendsServerList() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmakingServers_RequestHistoryServerList() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmakingServers_RequestInternetServerList() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmakingServers_RequestLANServerList() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmakingServers_RequestSpectatorServerList() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmakingServers_ServerRules() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmaking_AddFavoriteGame() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmaking_AddRequestLobbyListCompatibleMembersFilter() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmaking_AddRequestLobbyListDistanceFilter() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmaking_AddRequestLobbyListFilterSlotsAvailable() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmaking_AddRequestLobbyListNearValueFilter() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmaking_AddRequestLobbyListNumericalFilter() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmaking_AddRequestLobbyListResultCountFilter() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmaking_AddRequestLobbyListStringFilter() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmaking_CreateLobby() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmaking_DeleteLobbyData() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmaking_GetFavoriteGame() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmaking_GetFavoriteGameCount() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmaking_GetLobbyByIndex() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmaking_GetLobbyChatEntry() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmaking_GetLobbyData() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmaking_GetLobbyDataByIndex() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmaking_GetLobbyDataCount() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmaking_GetLobbyGameServer() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmaking_GetLobbyMemberByIndex() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmaking_GetLobbyMemberData() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmaking_GetLobbyMemberLimit() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmaking_GetLobbyOwner() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmaking_GetNumLobbyMembers() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmaking_InviteUserToLobby() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmaking_JoinLobby() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmaking_LeaveLobby() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmaking_RemoveFavoriteGame() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmaking_RequestLobbyData() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmaking_RequestLobbyList() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmaking_SendLobbyChatMsg() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmaking_SetLinkedLobby() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmaking_SetLobbyData() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmaking_SetLobbyGameServer() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmaking_SetLobbyJoinable() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmaking_SetLobbyMemberData() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmaking_SetLobbyMemberLimit() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmaking_SetLobbyOwner() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMatchmaking_SetLobbyType() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMusicRemote_BActivationSuccess() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMusicRemote_BIsCurrentMusicRemote() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMusicRemote_CurrentEntryDidChange() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMusicRemote_CurrentEntryIsAvailable() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMusicRemote_CurrentEntryWillChange() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMusicRemote_DeregisterSteamMusicRemote() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMusicRemote_EnableLooped() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMusicRemote_EnablePlayNext() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMusicRemote_EnablePlayPrevious() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMusicRemote_EnablePlaylists() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMusicRemote_EnableQueue() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMusicRemote_EnableShuffled() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMusicRemote_PlaylistDidChange() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMusicRemote_PlaylistWillChange() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMusicRemote_QueueDidChange() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMusicRemote_QueueWillChange() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMusicRemote_RegisterSteamMusicRemote() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMusicRemote_ResetPlaylistEntries() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMusicRemote_ResetQueueEntries() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMusicRemote_SetCurrentPlaylistEntry() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMusicRemote_SetCurrentQueueEntry() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMusicRemote_SetDisplayName() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMusicRemote_SetPNGIcon_64x64() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMusicRemote_SetPlaylistEntry() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMusicRemote_SetQueueEntry() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMusicRemote_UpdateCurrentEntryCoverArt() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMusicRemote_UpdateCurrentEntryElapsedSeconds() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMusicRemote_UpdateCurrentEntryText() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMusicRemote_UpdateLooped() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMusicRemote_UpdatePlaybackStatus() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMusicRemote_UpdateShuffled() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMusicRemote_UpdateVolume() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMusic_BIsEnabled() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMusic_BIsPlaying() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMusic_GetPlaybackStatus() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMusic_GetVolume() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMusic_Pause() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMusic_Play() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMusic_PlayNext() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMusic_PlayPrevious() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamMusic_SetVolume() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingConnectionCustomSignaling_Release() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingConnectionCustomSignaling_SendSignal() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingCustomSignalingRecvContext_OnConnectRequest() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingCustomSignalingRecvContext_SendRejectionSignal() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingFakeUDPPort_DestroyFakeUDPPort() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingFakeUDPPort_ReceiveMessages() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingFakeUDPPort_ScheduleCleanup() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingFakeUDPPort_SendMessageToFakeIP() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingMessages_AcceptSessionWithUser() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingMessages_CloseChannelWithUser() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingMessages_CloseSessionWithUser() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingMessages_GetSessionConnectionInfo() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingMessages_ReceiveMessagesOnChannel() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingMessages_SendMessageToUser() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_AcceptConnection() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_BeginAsyncRequestFakeIP() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_CloseConnection() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_CloseListenSocket() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_ConfigureConnectionLanes() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_ConnectByIPAddress() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_ConnectP2P() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_ConnectP2PCustomSignaling() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_ConnectToHostedDedicatedServer() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_CreateFakeUDPPort() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_CreateHostedDedicatedServerListenSocket() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_CreateListenSocketIP() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_CreateListenSocketP2P() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_CreateListenSocketP2PFakeIP() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_CreatePollGroup() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_CreateSocketPair() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_DestroyPollGroup() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_FindRelayAuthTicketForServer() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_FlushMessagesOnConnection() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_GetAuthenticationStatus() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_GetCertificateRequest() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_GetConnectionInfo() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_GetConnectionName() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_GetConnectionRealTimeStatus() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_GetConnectionUserData() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_GetDetailedConnectionStatus() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_GetFakeIP() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_GetGameCoordinatorServerLogin() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_GetHostedDedicatedServerAddress() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_GetHostedDedicatedServerPOPID() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_GetHostedDedicatedServerPort() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_GetIdentity() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_GetListenSocketAddress() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_GetQuickConnectionStatus() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_GetRemoteFakeIPForConnection() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_InitAuthentication() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_ReceiveMessagesOnConnection() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_ReceiveMessagesOnPollGroup() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_ReceivedP2PCustomSignal() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_ReceivedRelayAuthTicket() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_ResetIdentity() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_RunCallbacks() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_SendMessageToConnection() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_SendMessages() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_SetCertificate() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_SetConnectionName() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_SetConnectionPollGroup() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingSockets_SetConnectionUserData() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_AllocateMessage() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_CheckPingDataUpToDate() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_ConvertPingLocationToString() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_EstimatePingTimeBetweenTwoLocations() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_EstimatePingTimeFromLocalHost() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_GetConfigValue() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_GetConfigValueInfo() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_GetDirectPingToPOP() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_GetFirstConfigValue() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_GetIPv4FakeIPType() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_GetLocalPingLocation() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_GetLocalTimestamp() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_GetPOPCount() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_GetPOPList() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_GetPingToDataCenter() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_GetRealIdentityForFakeIP() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_GetRelayNetworkStatus() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_InitRelayNetworkAccess() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_IsFakeIPv4() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_IterateGenericEditableConfigValues() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_ParsePingLocationString() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_SetConfigValue() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_SetConfigValueStruct() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_SetConnectionConfigValueFloat() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_SetConnectionConfigValueInt32() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_SetConnectionConfigValueString() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_SetDebugOutputFunction() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_FakeIPResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_MessagesSessionFailed() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_MessagesSessionRequest() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_SteamNetAuthenticationStatusChanged() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_SteamNetConnectionStatusChanged() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_SteamRelayNetworkStatusChanged() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_SetGlobalConfigValueFloat() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_SetGlobalConfigValueInt32() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_SetGlobalConfigValuePtr() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_SetGlobalConfigValueString() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_SteamNetworkingIPAddr_GetFakeIPType() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_SteamNetworkingIPAddr_ParseString() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_SteamNetworkingIPAddr_ToString() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_SteamNetworkingIdentity_ParseString() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworkingUtils_SteamNetworkingIdentity_ToString() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworking_AcceptP2PSessionWithUser() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworking_AllowP2PPacketRelay() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworking_CloseP2PChannelWithUser() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworking_CloseP2PSessionWithUser() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworking_CreateConnectionSocket() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworking_CreateListenSocket() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworking_CreateP2PConnectionSocket() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworking_DestroyListenSocket() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworking_DestroySocket() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworking_GetListenSocketInfo() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworking_GetMaxPacketSize() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworking_GetP2PSessionState() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworking_GetSocketConnectionType() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworking_GetSocketInfo() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworking_IsDataAvailable() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworking_IsDataAvailableOnSocket() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworking_IsP2PPacketAvailable() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworking_ReadP2PPacket() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworking_RetrieveData() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworking_RetrieveDataFromSocket() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworking_SendDataOnSocket() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamNetworking_SendP2PPacket() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamParentalSettings_BIsAppBlocked() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamParentalSettings_BIsAppInBlockList() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamParentalSettings_BIsFeatureBlocked() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamParentalSettings_BIsFeatureInBlockList() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamParentalSettings_BIsParentalLockEnabled() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamParentalSettings_BIsParentalLockLocked() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamParties_CancelReservation() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamParties_ChangeNumOpenSlots() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamParties_CreateBeacon() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamParties_DestroyBeacon() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamParties_GetAvailableBeaconLocations() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamParties_GetBeaconByIndex() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamParties_GetBeaconDetails() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamParties_GetBeaconLocationData() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamParties_GetNumActiveBeacons() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamParties_GetNumAvailableBeaconLocations() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamParties_JoinParty() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamParties_OnReservationCompleted() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemotePlay_BEnableRemotePlayTogetherDirectInput() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemotePlay_BGetSessionClientResolution() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemotePlay_BSendRemotePlayTogetherInvite() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemotePlay_BStartRemotePlayTogether() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemotePlay_CreateMouseCursor() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemotePlay_DisableRemotePlayTogetherDirectInput() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemotePlay_GetInput() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemotePlay_GetSessionClientFormFactor() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemotePlay_GetSessionClientName() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemotePlay_GetSessionCount() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemotePlay_GetSessionID() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemotePlay_GetSessionSteamID() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemotePlay_SetMouseCursor() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemotePlay_SetMousePosition() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemotePlay_SetMouseVisibility() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemotePlay_ShowRemotePlayTogetherUI() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_BeginFileWriteBatch() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_CommitPublishedFileUpdate() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_CreatePublishedFileUpdateRequest() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_DeletePublishedFile() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_EndFileWriteBatch() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_EnumeratePublishedFilesByUserAction() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_EnumeratePublishedWorkshopFiles() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_EnumerateUserPublishedFiles() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_EnumerateUserSharedWorkshopFiles() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_EnumerateUserSubscribedFiles() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_FileDelete() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_FileExists() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_FileForget() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_FilePersisted() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_FileRead() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_FileReadAsync() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_FileReadAsyncComplete() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_FileShare() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_FileWrite() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_FileWriteAsync() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_FileWriteStreamCancel() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_FileWriteStreamClose() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_FileWriteStreamOpen() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_FileWriteStreamWriteChunk() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_GetCachedUGCCount() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_GetCachedUGCHandle() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_GetFileCount() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_GetFileNameAndSize() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_GetFileSize() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_GetFileTimestamp() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_GetLocalFileChange() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_GetLocalFileChangeCount() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_GetPublishedFileDetails() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_GetPublishedItemVoteDetails() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_GetQuota() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_GetSyncPlatforms() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_GetUGCDetails() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_GetUGCDownloadProgress() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_GetUserPublishedItemVoteDetails() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_IsCloudEnabledForAccount() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_IsCloudEnabledForApp() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_PublishVideo() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_PublishWorkshopFile() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_SetCloudEnabledForApp() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_SetSyncPlatforms() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_SetUserPublishedFileAction() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_SubscribePublishedFile() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_UGCDownload() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_UGCDownloadToLocation() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_UGCRead() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_UnsubscribePublishedFile() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_UpdatePublishedFileDescription() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_UpdatePublishedFileFile() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_UpdatePublishedFilePreviewFile() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_UpdatePublishedFileSetChangeDescription() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_UpdatePublishedFileTags() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_UpdatePublishedFileTitle() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_UpdatePublishedFileVisibility() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamRemoteStorage_UpdateUserPublishedItemVote() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamScreenshots_AddScreenshotToLibrary() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamScreenshots_AddVRScreenshotToLibrary() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamScreenshots_HookScreenshots() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamScreenshots_IsScreenshotsHooked() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamScreenshots_SetLocation() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamScreenshots_TagPublishedFile() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamScreenshots_TagUser() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamScreenshots_TriggerScreenshot() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamScreenshots_WriteScreenshot() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamTV_AddBroadcastGameData() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamTV_AddRegion() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamTV_AddTimelineMarker() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamTV_IsBroadcasting() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamTV_RemoveBroadcastGameData() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamTV_RemoveRegion() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamTV_RemoveTimelineMarker() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamTimeline_AddGamePhaseTag() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamTimeline_AddInstantaneousTimelineEvent() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamTimeline_AddRangeTimelineEvent() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamTimeline_AddTimelineEvent() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamTimeline_ClearTimelineStateDescription() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamTimeline_ClearTimelineTooltip() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamTimeline_DoesEventRecordingExist() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamTimeline_DoesGamePhaseRecordingExist() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamTimeline_EndGamePhase() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamTimeline_EndRangeTimelineEvent() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamTimeline_OpenOverlayToGamePhase() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamTimeline_OpenOverlayToTimelineEvent() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamTimeline_RemoveTimelineEvent() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamTimeline_SetGamePhaseAttribute() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamTimeline_SetGamePhaseID() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamTimeline_SetTimelineGameMode() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamTimeline_SetTimelineStateDescription() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamTimeline_SetTimelineTooltip() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamTimeline_StartGamePhase() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamTimeline_StartRangeTimelineEvent() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamTimeline_UpdateRangeTimelineEvent() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_AddAppDependency() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_AddContentDescriptor() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_AddDependency() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_AddExcludedTag() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_AddItemKeyValueTag() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_AddItemPreviewFile() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_AddItemPreviewVideo() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_AddItemToFavorites() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_AddRequiredKeyValueTag() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_AddRequiredTag() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_AddRequiredTagGroup() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_BInitWorkshopForGameServer() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_CreateItem() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_CreateQueryAllUGCRequest() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_CreateQueryAllUGCRequest0() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_CreateQueryAllUGCRequestCursor() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_CreateQueryAllUGCRequestPage() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_CreateQueryUGCDetailsRequest() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_CreateQueryUserUGCRequest() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_DeleteItem() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_DownloadItem() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_GetAppDependencies() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_GetItemDownloadInfo() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_GetItemInstallInfo() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_GetItemState() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_GetItemUpdateProgress() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_GetNumSubscribedItems() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_GetNumSupportedGameVersions() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_GetQueryFirstUGCKeyValueTag() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_GetQueryUGCAdditionalPreview() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_GetQueryUGCChildren() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_GetQueryUGCContentDescriptors() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_GetQueryUGCKeyValueTag() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_GetQueryUGCKeyValueTag0() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_GetQueryUGCMetadata() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_GetQueryUGCNumAdditionalPreviews() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_GetQueryUGCNumKeyValueTags() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_GetQueryUGCNumTags() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_GetQueryUGCPreviewURL() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_GetQueryUGCResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_GetQueryUGCStatistic() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_GetQueryUGCTag() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_GetQueryUGCTagDisplayName() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_GetSubscribedItems() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_GetSupportedGameVersionData() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_GetUserContentDescriptorPreferences() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_GetUserItemVote() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_GetWorkshopEULAStatus() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_ReleaseQueryUGCRequest() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_RemoveAllItemKeyValueTags() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_RemoveAppDependency() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_RemoveContentDescriptor() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_RemoveDependency() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_RemoveItemFromFavorites() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_RemoveItemKeyValueTags() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_RemoveItemPreview() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_RequestUGCDetails() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_SendQueryUGCRequest() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_SetAdminQuery() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_SetAllowCachedResponse() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_SetAllowLegacyUpload() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_SetCloudFileNameFilter() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_SetItemContent() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_SetItemDescription() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_SetItemMetadata() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_SetItemPreview() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_SetItemTags() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_SetItemTitle() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_SetItemUpdateLanguage() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_SetItemVisibility() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_SetItemsDisabledLocally() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_SetLanguage() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_SetMatchAnyTag() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_SetRankedByTrendDays() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_SetRequiredGameVersions() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_SetReturnAdditionalPreviews() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_SetReturnChildren() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_SetReturnKeyValueTags() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_SetReturnLongDescription() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_SetReturnMetadata() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_SetReturnOnlyIDs() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_SetReturnPlaytimeStats() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_SetReturnTotalOnly() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_SetSearchText() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_SetSubscriptionsLoadOrder() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_SetTimeCreatedDateRange() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_SetTimeUpdatedDateRange() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_SetUserItemVote() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_ShowWorkshopEULA() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_StartItemUpdate() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_StartPlaytimeTracking() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_StopPlaytimeTracking() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_StopPlaytimeTrackingForAllItems() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_SubmitItemUpdate() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_SubscribeItem() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_SuspendDownloads() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_UnsubscribeItem() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_UpdateItemPreviewFile() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUGC_UpdateItemPreviewVideo() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUnifiedMessages_GetMethodResponseData() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUnifiedMessages_GetMethodResponseInfo() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUnifiedMessages_ReleaseMethod() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUnifiedMessages_SendMethod() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUnifiedMessages_SendNotification() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUserStats_AttachLeaderboardUGC() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUserStats_ClearAchievement() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUserStats_DownloadLeaderboardEntries() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUserStats_DownloadLeaderboardEntriesForUsers() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUserStats_FindLeaderboard() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUserStats_FindOrCreateLeaderboard() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUserStats_GetAchievement() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUserStats_GetAchievementAchievedPercent() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUserStats_GetAchievementAndUnlockTime() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUserStats_GetAchievementDisplayAttribute() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUserStats_GetAchievementIcon() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUserStats_GetAchievementName() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUserStats_GetAchievementProgressLimitsFloat() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUserStats_GetAchievementProgressLimitsInt32() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUserStats_GetDownloadedLeaderboardEntry() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUserStats_GetGlobalStat() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUserStats_GetGlobalStat0() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUserStats_GetGlobalStatDouble() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUserStats_GetGlobalStatHistory() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUserStats_GetGlobalStatHistory0() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUserStats_GetGlobalStatHistoryDouble() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUserStats_GetGlobalStatHistoryInt64() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUserStats_GetGlobalStatInt64() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUserStats_GetLeaderboardDisplayType() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUserStats_GetLeaderboardEntryCount() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUserStats_GetLeaderboardName() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUserStats_GetLeaderboardSortMethod() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUserStats_GetMostAchievedAchievementInfo() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUserStats_GetNextMostAchievedAchievementInfo() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUserStats_GetNumAchievements() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUserStats_GetNumberOfCurrentPlayers() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUserStats_GetStat() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUserStats_GetStat0() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUserStats_GetStatFloat() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUserStats_GetStatInt32() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUserStats_GetUserAchievement() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUserStats_GetUserAchievementAndUnlockTime() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUserStats_GetUserStat() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUserStats_GetUserStat0() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUserStats_GetUserStatFloat() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUserStats_GetUserStatInt32() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUserStats_IndicateAchievementProgress() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUserStats_RequestCurrentStats() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUserStats_RequestGlobalAchievementPercentages() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUserStats_RequestGlobalStats() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUserStats_RequestUserStats() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUserStats_ResetAllStats() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUserStats_SetAchievement() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUserStats_SetStat() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUserStats_SetStat0() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUserStats_SetStatFloat() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUserStats_SetStatInt32() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUserStats_StoreStats() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUserStats_UpdateAvgRateStat() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUserStats_UploadLeaderboardScore() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUser_AdvertiseGame() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUser_BIsBehindNAT() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUser_BIsPhoneIdentifying() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUser_BIsPhoneRequiringVerification() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUser_BIsPhoneVerified() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUser_BIsTwoFactorEnabled() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUser_BLoggedOn() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUser_BSetDurationControlOnlineState() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUser_BeginAuthSession() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUser_CancelAuthTicket() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUser_DecompressVoice() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUser_EndAuthSession() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUser_GetAuthSessionTicket() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUser_GetAuthTicketForWebApi() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUser_GetAvailableVoice() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUser_GetDurationControl() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUser_GetEncryptedAppTicket() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUser_GetGameBadgeLevel() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUser_GetHSteamUser() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUser_GetMarketEligibility() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUser_GetPlayerSteamLevel() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUser_GetSteamID() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUser_GetUserDataFolder() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUser_GetVoice() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUser_GetVoiceOptimalSampleRate() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUser_InitiateGameConnection() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUser_InitiateGameConnection_DEPRECATED() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUser_RequestEncryptedAppTicket() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUser_RequestStoreAuthURL() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUser_StartVoiceRecording() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUser_StopVoiceRecording() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUser_TerminateGameConnection() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUser_TerminateGameConnection_DEPRECATED() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUser_TrackAppUsageEvent() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUser_UserHasLicenseForApp() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUtils_BOverlayNeedsPresent() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUtils_CheckFileSignature() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUtils_DismissFloatingGamepadTextInput() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUtils_DismissGamepadTextInput() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUtils_FilterText() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUtils_GetAPICallFailureReason() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUtils_GetAPICallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUtils_GetAppID() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUtils_GetCSERIPPort() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUtils_GetConnectedUniverse() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUtils_GetCurrentBatteryPower() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUtils_GetEnteredGamepadTextInput() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUtils_GetEnteredGamepadTextLength() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUtils_GetIPCCallCount() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUtils_GetIPCountry() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUtils_GetIPv6ConnectivityState() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUtils_GetImageRGBA() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUtils_GetImageSize() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUtils_GetSecondsSinceAppActive() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUtils_GetSecondsSinceComputerActive() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUtils_GetServerRealTime() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUtils_GetSteamUILanguage() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUtils_InitFilterText() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUtils_IsAPICallCompleted() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUtils_IsOverlayEnabled() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUtils_IsSteamChinaLauncher() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUtils_IsSteamInBigPictureMode() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUtils_IsSteamRunningInVR() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUtils_IsSteamRunningOnSteamDeck() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUtils_IsVRHeadsetStreamingEnabled() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUtils_RunFrame() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUtils_SetGameLauncherMode() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUtils_SetOverlayNotificationInset() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUtils_SetOverlayNotificationPosition() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUtils_SetVRHeadsetStreamingEnabled() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUtils_SetWarningMessageHook() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUtils_ShowFloatingGamepadTextInput() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUtils_ShowGamepadTextInput() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUtils_ShowModalGamepadTextInput() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamUtils_StartVRDashboard() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamVideo_AddTimelineHighlightMarker() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamVideo_AddTimelineRange() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamVideo_AddTimelineRangeEnd() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamVideo_AddTimelineRangeStart() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamVideo_AddTimelineTimestamp() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamVideo_GetOPFSettings() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamVideo_GetOPFStringForApp() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamVideo_GetVideoURL() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamVideo_IsBroadcasting() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ISteamVideo_SetTimelineGameMode() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_Init() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_InitAnonymousUser() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_InitFlat() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_InitSafe() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_IsSteamRunning() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ManualDispatch_FreeLastCallback() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ManualDispatch_GetAPICallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ManualDispatch_GetNextCallback() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ManualDispatch_Init() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ManualDispatch_RunFrame() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_MatchMakingKeyValuePair_t_Construct() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_RegisterCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_RegisterCallback() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_ReleaseCurrentThreadMemory() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_RestartAppIfNecessary() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_RunCallbacks() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SetBreakpadAppID() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SetMiniDumpComment() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SetTryCatchCallbacks() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_Shutdown() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamAppList_v001() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamApps_v008() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamController_v007() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamController_v008() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamDatagramHostedAddress_Clear() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamDatagramHostedAddress_GetPopID() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamDatagramHostedAddress_SetDevAddress() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamFriends_v017() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamFriends_v018() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamGameSearch_v001() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamGameServerApps_v008() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamGameServerHTTP_v003() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamGameServerInventory_v003() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamGameServerNetworkingMessages_SteamAPI_v002() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamGameServerNetworkingMessages_v002() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamGameServerNetworkingSockets_SteamAPI_v009() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamGameServerNetworkingSockets_SteamAPI_v011() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamGameServerNetworkingSockets_SteamAPI_v012() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamGameServerNetworkingSockets_v008() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamGameServerNetworkingSockets_v009() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamGameServerNetworking_v006() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamGameServerStats_v001() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamGameServerUGC_v014() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamGameServerUGC_v015() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamGameServerUGC_v016() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamGameServerUGC_v017() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamGameServerUGC_v018() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamGameServerUGC_v020() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamGameServerUGC_v021() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamGameServerUtils_v009() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamGameServerUtils_v010() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamGameServer_v013() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamGameServer_v014() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamGameServer_v015() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamHTMLSurface_v005() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamHTTP_v003() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamIPAddress_t_IsSet() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamInput_v001() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamInput_v002() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamInput_v005() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamInput_v006() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamInventory_v003() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamMatchmakingServers_v002() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamMatchmaking_v009() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamMusicRemote_v001() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamMusic_v001() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamNetworkingConfigValue_t_SetFloat() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamNetworkingConfigValue_t_SetInt32() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamNetworkingConfigValue_t_SetInt64() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamNetworkingConfigValue_t_SetPtr() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamNetworkingConfigValue_t_SetString() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamNetworkingIPAddrRender_c_str() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamNetworkingIPAddr_Clear() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamNetworkingIPAddr_GetFakeIPType() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamNetworkingIPAddr_GetIPv4() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamNetworkingIPAddr_IsEqualTo() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamNetworkingIPAddr_IsFakeIP() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamNetworkingIPAddr_IsIPv4() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamNetworkingIPAddr_IsIPv6AllZeros() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamNetworkingIPAddr_IsLocalHost() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamNetworkingIPAddr_ParseString() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamNetworkingIPAddr_SetIPv4() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamNetworkingIPAddr_SetIPv6() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamNetworkingIPAddr_SetIPv6LocalHost() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamNetworkingIPAddr_ToString() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamNetworkingIdentityRender_c_str() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamNetworkingIdentity_Clear() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamNetworkingIdentity_GetFakeIPType() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamNetworkingIdentity_GetGenericBytes() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamNetworkingIdentity_GetGenericString() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamNetworkingIdentity_GetIPAddr() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamNetworkingIdentity_GetIPv4() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamNetworkingIdentity_GetPSNID() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamNetworkingIdentity_GetStadiaID() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamNetworkingIdentity_GetSteamID() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamNetworkingIdentity_GetSteamID64() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamNetworkingIdentity_GetXboxPairwiseID() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamNetworkingIdentity_IsEqualTo() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamNetworkingIdentity_IsFakeIP() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamNetworkingIdentity_IsInvalid() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamNetworkingIdentity_IsLocalHost() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamNetworkingIdentity_ParseString() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamNetworkingIdentity_SetGenericBytes() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamNetworkingIdentity_SetGenericString() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamNetworkingIdentity_SetIPAddr() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamNetworkingIdentity_SetIPv4Addr() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamNetworkingIdentity_SetLocalHost() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamNetworkingIdentity_SetPSNID() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamNetworkingIdentity_SetStadiaID() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamNetworkingIdentity_SetSteamID() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamNetworkingIdentity_SetSteamID64() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamNetworkingIdentity_SetXboxPairwiseID() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamNetworkingIdentity_ToString() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamNetworkingMessage_t_Release() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamNetworkingMessages_SteamAPI_v002() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamNetworkingMessages_v002() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamNetworkingPOPIDRender_c_str() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamNetworkingSockets_SteamAPI_v009() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamNetworkingSockets_SteamAPI_v011() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamNetworkingSockets_SteamAPI_v012() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamNetworkingSockets_v008() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamNetworkingSockets_v009() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamNetworkingUtils_SteamAPI_v003() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamNetworkingUtils_SteamAPI_v004() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamNetworkingUtils_v003() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamNetworking_v006() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamParentalSettings_v001() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamParties_v002() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamRemotePlay_v001() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamRemotePlay_v002() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamRemotePlay_v003() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamRemoteStorage_v014() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamRemoteStorage_v016() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamScreenshots_v003() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamTV_v001() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamTimeline_v001() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamTimeline_v004() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamUGC_v014() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamUGC_v015() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamUGC_v016() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamUGC_v017() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamUGC_v018() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamUGC_v020() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamUGC_v021() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamUserStats_v011() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamUserStats_v012() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamUserStats_v013() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamUser_v020() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamUser_v021() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamUser_v022() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamUser_v023() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamUtils_v009() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamUtils_v010() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamVideo_v002() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamVideo_v003() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamVideo_v004() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_SteamVideo_v007() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_UnregisterCallResult() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_UnregisterCallback() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_UseBreakpadCrashHandler() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_WriteMiniDump() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_gameserveritem_t_Construct() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_gameserveritem_t_GetName() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_gameserveritem_t_SetName() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_servernetadr_t_Assign() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_servernetadr_t_Construct() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_servernetadr_t_GetConnectionAddressString() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_servernetadr_t_GetConnectionPort() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_servernetadr_t_GetIP() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_servernetadr_t_GetQueryAddressString() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_servernetadr_t_GetQueryPort() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_servernetadr_t_Init() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_servernetadr_t_IsLessThan() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_servernetadr_t_SetConnectionPort() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_servernetadr_t_SetIP() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAPI_servernetadr_t_SetQueryPort() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamAppList() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamApps() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamClient() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamContentServer() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamContentServerUtils() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamContentServer_Init() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamContentServer_RunCallbacks() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamContentServer_Shutdown() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamController() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamController_GetControllerState() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamController_Init() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamController_SetOverrideMode() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamController_Shutdown() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamController_TriggerHapticPulse() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamFriends() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamGameServer() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamGameServerApps() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamGameServerHTTP() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamGameServerInventory() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamGameServerNetworking() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamGameServerStats() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamGameServerUGC() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamGameServerUtils() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamGameServer_BSecure() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamGameServer_GetHSteamPipe() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamGameServer_GetHSteamUser() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamGameServer_GetIPCCallCount() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamGameServer_GetSteamID() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamGameServer_Init() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamGameServer_InitSafe() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamGameServer_RunCallbacks() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamGameServer_Shutdown() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamHTMLSurface() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamHTTP() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamInternal_ContextInit() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamInternal_CreateInterface() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamInternal_FindOrCreateGameServerInterface() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamInternal_FindOrCreateUserInterface() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamInternal_GameServer_Init() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamInternal_GameServer_Init_V2() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamInternal_GlobalContextGameServerPtr() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamInternal_SteamAPI_Init() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamInventory() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamMasterServerUpdater() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamMatchmaking() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamMatchmakingServers() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamMusic() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamMusicRemote() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamNetworking() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamRealPath() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamRemoteStorage() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamScreenshots() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamUGC() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamUnifiedMessages() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamUser() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamUserStats() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamUtils() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamVR_ComputeDistortion() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamVR_GetD3D9AdapterIndex() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamVR_GetDisplayId() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamVR_GetDriverId() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamVR_GetEyeOutputViewport() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamVR_GetHeadFromEyePose() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamVR_GetLastTrackerFromHeadPose() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamVR_GetProjectionMatrix() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamVR_GetProjectionRaw() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamVR_GetRecommendedRenderTargetSize() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamVR_GetTrackerFromHeadPose() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamVR_GetTrackerZeroPose() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamVR_GetViewMatrix() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamVR_GetWindowBounds() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamVR_IHmd_Version() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamVR_WillDriftInYaw() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamVR_ZeroTracker() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void SteamVideo() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void Steam_BGetCallback() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void Steam_FreeLastCallback() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void Steam_GetHSteamUserCurrent() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void Steam_RegisterInterfaceFuncs() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void Steam_RunCallbacks() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void VR_GetControlPanel() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void VR_GetGenericInterface() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void VR_GetStringForHmdError() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void VR_Init() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void VR_IsHmdPresent() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void VR_Shutdown() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}

EXPORT void g_pSteamClientGameServer() {
    asm volatile ("movl $0xDeadC0de, %%eax":::"eax");
    asm volatile ("jmp *%eax");
}


namespace {
    void panic_exit(){
        koalabox::util::panic("Invocation of uninitialized exported function.");
    }
}

namespace proxy_exports {
    void init(void* const self_lib_handle, void* const original_lib_handle) {
        static std::mutex section;
        const std::lock_guard lock(section);

        static bool initialized = false;
        if(initialized) {
            LOG_WARN("proxy_exports is already initialized");
            return;
        }

        LOG_INFO(
            "Initializing proxy_exports. self handle: {}, original handle: {}",
            self_lib_handle, original_lib_handle
        );

        const auto code_section = koalabox::lib::get_section_or_throw(self_lib_handle, koalabox::lib::CODE_SECTION);
        PLH::MemAccessor mem_accessor;
        PLH::MemoryProtector const protector(
            reinterpret_cast<uint64_t>(code_section.start_address),
            code_section.size,
            PLH::ProtFlag::RWX,
            mem_accessor
        );

        void* src_address = nullptr;
        void* dest_address = nullptr;

        dest_address = dlsym(self_lib_handle, "CAddAppDependencyResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CAddAppDependencyResult_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CAddAppDependencyResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CAddAppDependencyResult_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CAddUGCDependencyResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CAddUGCDependencyResult_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CAddUGCDependencyResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CAddUGCDependencyResult_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CAssociateWithClanResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CAssociateWithClanResult_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CAssociateWithClanResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CAssociateWithClanResult_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CChangeNumOpenSlotsCallback_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CChangeNumOpenSlotsCallback_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CChangeNumOpenSlotsCallback_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CChangeNumOpenSlotsCallback_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CCheckFileSignature_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CCheckFileSignature_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CCheckFileSignature_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CCheckFileSignature_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CClanOfficerListResponse_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CClanOfficerListResponse_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CClanOfficerListResponse_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CClanOfficerListResponse_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CComputeNewPlayerCompatibilityResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CComputeNewPlayerCompatibilityResult_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CComputeNewPlayerCompatibilityResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CComputeNewPlayerCompatibilityResult_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CCreateBeaconCallback_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CCreateBeaconCallback_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CCreateBeaconCallback_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CCreateBeaconCallback_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CCreateItemResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CCreateItemResult_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CCreateItemResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CCreateItemResult_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CDeleteItemResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CDeleteItemResult_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CDeleteItemResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CDeleteItemResult_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CDurationControl_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CDurationControl_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CDurationControl_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CDurationControl_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CEncryptedAppTicketResponse_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CEncryptedAppTicketResponse_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CEncryptedAppTicketResponse_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CEncryptedAppTicketResponse_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CFileDetailsResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CFileDetailsResult_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CFileDetailsResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CFileDetailsResult_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CFriendsEnumerateFollowingList_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CFriendsEnumerateFollowingList_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CFriendsEnumerateFollowingList_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CFriendsEnumerateFollowingList_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CFriendsGetFollowerCount_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CFriendsGetFollowerCount_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CFriendsGetFollowerCount_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CFriendsGetFollowerCount_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CFriendsIsFollowing_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CFriendsIsFollowing_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CFriendsIsFollowing_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CFriendsIsFollowing_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CGSReputation_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CGSReputation_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CGSReputation_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CGSReputation_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CGSStatsReceived_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CGSStatsReceived_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CGSStatsReceived_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CGSStatsReceived_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CGSStatsStored_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CGSStatsStored_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CGSStatsStored_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CGSStatsStored_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CGetAppDependenciesResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CGetAppDependenciesResult_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CGetAppDependenciesResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CGetAppDependenciesResult_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CGetOPFSettingsResult_t_RemoveCallback");
        src_address = dlsym(original_lib_handle, "CGetOPFSettingsResult_t_RemoveCallback");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CGetOPFSettingsResult_t_SetCallback");
        src_address = dlsym(original_lib_handle, "CGetOPFSettingsResult_t_SetCallback");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CGetUserItemVoteResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CGetUserItemVoteResult_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CGetUserItemVoteResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CGetUserItemVoteResult_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CGlobalAchievementPercentagesReady_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CGlobalAchievementPercentagesReady_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CGlobalAchievementPercentagesReady_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CGlobalAchievementPercentagesReady_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CGlobalStatsReceived_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CGlobalStatsReceived_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CGlobalStatsReceived_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CGlobalStatsReceived_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CHTML_BrowserReady_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CHTML_BrowserReady_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CHTML_BrowserReady_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CHTML_BrowserReady_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CJoinClanChatRoomCompletionResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CJoinClanChatRoomCompletionResult_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CJoinClanChatRoomCompletionResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CJoinClanChatRoomCompletionResult_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CJoinPartyCallback_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CJoinPartyCallback_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CJoinPartyCallback_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CJoinPartyCallback_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CLeaderboardFindResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CLeaderboardFindResult_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CLeaderboardFindResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CLeaderboardFindResult_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CLeaderboardScoreUploaded_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CLeaderboardScoreUploaded_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CLeaderboardScoreUploaded_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CLeaderboardScoreUploaded_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CLeaderboardScoresDownloaded_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CLeaderboardScoresDownloaded_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CLeaderboardScoresDownloaded_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CLeaderboardScoresDownloaded_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CLeaderboardUGCSet_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CLeaderboardUGCSet_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CLeaderboardUGCSet_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CLeaderboardUGCSet_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CLobbyCreated_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CLobbyCreated_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CLobbyCreated_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CLobbyCreated_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CLobbyEnter_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CLobbyEnter_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CLobbyEnter_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CLobbyEnter_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CLobbyMatchList_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CLobbyMatchList_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CLobbyMatchList_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CLobbyMatchList_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CMarketEligibilityResponse_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CMarketEligibilityResponse_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CMarketEligibilityResponse_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CMarketEligibilityResponse_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CNumberOfCurrentPlayers_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CNumberOfCurrentPlayers_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CNumberOfCurrentPlayers_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CNumberOfCurrentPlayers_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CPublisherOwnedAppDataReady_t_RemoveCallback");
        src_address = dlsym(original_lib_handle, "CPublisherOwnedAppDataReady_t_RemoveCallback");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CPublisherOwnedAppDataReady_t_SetCallback");
        src_address = dlsym(original_lib_handle, "CPublisherOwnedAppDataReady_t_SetCallback");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStorageDeletePublishedFileResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStorageDeletePublishedFileResult_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStorageDeletePublishedFileResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStorageDeletePublishedFileResult_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStorageDownloadUGCResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStorageDownloadUGCResult_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStorageDownloadUGCResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStorageDownloadUGCResult_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStorageEnumeratePublishedFilesByUserActionResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStorageEnumeratePublishedFilesByUserActionResult_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStorageEnumeratePublishedFilesByUserActionResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStorageEnumeratePublishedFilesByUserActionResult_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStorageEnumerateUserPublishedFilesResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStorageEnumerateUserPublishedFilesResult_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStorageEnumerateUserPublishedFilesResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStorageEnumerateUserPublishedFilesResult_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStorageEnumerateUserSubscribedFilesResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStorageEnumerateUserSubscribedFilesResult_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStorageEnumerateUserSubscribedFilesResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStorageEnumerateUserSubscribedFilesResult_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStorageEnumerateWorkshopFilesResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStorageEnumerateWorkshopFilesResult_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStorageEnumerateWorkshopFilesResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStorageEnumerateWorkshopFilesResult_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStorageFileReadAsyncComplete_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStorageFileReadAsyncComplete_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStorageFileReadAsyncComplete_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStorageFileReadAsyncComplete_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStorageFileShareResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStorageFileShareResult_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStorageFileShareResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStorageFileShareResult_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStorageFileWriteAsyncComplete_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStorageFileWriteAsyncComplete_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStorageFileWriteAsyncComplete_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStorageFileWriteAsyncComplete_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStorageGetPublishedFileDetailsResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStorageGetPublishedFileDetailsResult_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStorageGetPublishedFileDetailsResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStorageGetPublishedFileDetailsResult_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStorageGetPublishedItemVoteDetailsResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStorageGetPublishedItemVoteDetailsResult_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStorageGetPublishedItemVoteDetailsResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStorageGetPublishedItemVoteDetailsResult_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStoragePublishFileProgress_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStoragePublishFileProgress_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStoragePublishFileProgress_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStoragePublishFileProgress_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStorageSetUserPublishedFileActionResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStorageSetUserPublishedFileActionResult_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStorageSetUserPublishedFileActionResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStorageSetUserPublishedFileActionResult_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStorageSubscribePublishedFileResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStorageSubscribePublishedFileResult_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStorageSubscribePublishedFileResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStorageSubscribePublishedFileResult_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStorageUnsubscribePublishedFileResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStorageUnsubscribePublishedFileResult_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStorageUnsubscribePublishedFileResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStorageUnsubscribePublishedFileResult_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStorageUpdatePublishedFileResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStorageUpdatePublishedFileResult_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStorageUpdatePublishedFileResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStorageUpdatePublishedFileResult_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStorageUpdateUserPublishedItemVoteResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStorageUpdateUserPublishedItemVoteResult_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoteStorageUpdateUserPublishedItemVoteResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CRemoteStorageUpdateUserPublishedItemVoteResult_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoveAppDependencyResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CRemoveAppDependencyResult_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoveAppDependencyResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CRemoveAppDependencyResult_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoveUGCDependencyResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CRemoveUGCDependencyResult_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CRemoveUGCDependencyResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CRemoveUGCDependencyResult_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CSetPersonaNameResponse_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CSetPersonaNameResponse_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CSetPersonaNameResponse_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CSetPersonaNameResponse_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CSetUserItemVoteResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CSetUserItemVoteResult_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CSetUserItemVoteResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CSetUserItemVoteResult_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CStartPlaytimeTrackingResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CStartPlaytimeTrackingResult_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CStartPlaytimeTrackingResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CStartPlaytimeTrackingResult_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CSteamInventoryEligiblePromoItemDefIDs_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CSteamInventoryEligiblePromoItemDefIDs_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CSteamInventoryEligiblePromoItemDefIDs_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CSteamInventoryEligiblePromoItemDefIDs_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CSteamInventoryRequestPricesResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CSteamInventoryRequestPricesResult_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CSteamInventoryRequestPricesResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CSteamInventoryRequestPricesResult_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CSteamInventoryStartPurchaseResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CSteamInventoryStartPurchaseResult_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CSteamInventoryStartPurchaseResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CSteamInventoryStartPurchaseResult_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CSteamUGCQueryCompleted_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CSteamUGCQueryCompleted_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CSteamUGCQueryCompleted_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CSteamUGCQueryCompleted_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CStopPlaytimeTrackingResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CStopPlaytimeTrackingResult_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CStopPlaytimeTrackingResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CStopPlaytimeTrackingResult_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CStoreAuthURLResponse_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CStoreAuthURLResponse_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CStoreAuthURLResponse_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CStoreAuthURLResponse_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CSubmitItemUpdateResult_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CSubmitItemUpdateResult_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CSubmitItemUpdateResult_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CSubmitItemUpdateResult_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CUserFavoriteItemsListChanged_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CUserFavoriteItemsListChanged_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CUserFavoriteItemsListChanged_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CUserFavoriteItemsListChanged_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CUserStatsReceived_t_RemoveCallResult");
        src_address = dlsym(original_lib_handle, "CUserStatsReceived_t_RemoveCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CUserStatsReceived_t_RemoveCallback");
        src_address = dlsym(original_lib_handle, "CUserStatsReceived_t_RemoveCallback");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CUserStatsReceived_t_SetCallResult");
        src_address = dlsym(original_lib_handle, "CUserStatsReceived_t_SetCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "CUserStatsReceived_t_SetCallback");
        src_address = dlsym(original_lib_handle, "CUserStatsReceived_t_SetCallback");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "GetHSteamPipe");
        src_address = dlsym(original_lib_handle, "GetHSteamPipe");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "GetHSteamUser");
        src_address = dlsym(original_lib_handle, "GetHSteamUser");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "ISteamApps_BIsCybercafe");
        src_address = dlsym(original_lib_handle, "ISteamApps_BIsCybercafe");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "ISteamApps_BIsLowViolence");
        src_address = dlsym(original_lib_handle, "ISteamApps_BIsLowViolence");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "ISteamApps_BIsSubscribed");
        src_address = dlsym(original_lib_handle, "ISteamApps_BIsSubscribed");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "ISteamApps_BIsSubscribedApp");
        src_address = dlsym(original_lib_handle, "ISteamApps_BIsSubscribedApp");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "ISteamApps_GetAvailableGameLanguages");
        src_address = dlsym(original_lib_handle, "ISteamApps_GetAvailableGameLanguages");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "ISteamApps_GetCurrentGameLanguage");
        src_address = dlsym(original_lib_handle, "ISteamApps_GetCurrentGameLanguage");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "ISteamClient_SetLocalIPBinding");
        src_address = dlsym(original_lib_handle, "ISteamClient_SetLocalIPBinding");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "ISteamGameServer_BLoggedOn");
        src_address = dlsym(original_lib_handle, "ISteamGameServer_BLoggedOn");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "ISteamGameServer_BSecure");
        src_address = dlsym(original_lib_handle, "ISteamGameServer_BSecure");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "ISteamGameServer_BUpdateUserData");
        src_address = dlsym(original_lib_handle, "ISteamGameServer_BUpdateUserData");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "ISteamGameServer_CreateUnauthenticatedUserConnection");
        src_address = dlsym(original_lib_handle, "ISteamGameServer_CreateUnauthenticatedUserConnection");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "ISteamGameServer_GetSteamID");
        src_address = dlsym(original_lib_handle, "ISteamGameServer_GetSteamID");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "ISteamGameServer_SendUserConnectAndAuthenticate");
        src_address = dlsym(original_lib_handle, "ISteamGameServer_SendUserConnectAndAuthenticate");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "ISteamGameServer_SendUserDisconnect");
        src_address = dlsym(original_lib_handle, "ISteamGameServer_SendUserDisconnect");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "ISteamGameServer_SetGameType");
        src_address = dlsym(original_lib_handle, "ISteamGameServer_SetGameType");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "ISteamGameServer_SetServerType");
        src_address = dlsym(original_lib_handle, "ISteamGameServer_SetServerType");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "ISteamGameServer_UpdateSpectatorPort");
        src_address = dlsym(original_lib_handle, "ISteamGameServer_UpdateSpectatorPort");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "ISteamGameServer_UpdateStatus");
        src_address = dlsym(original_lib_handle, "ISteamGameServer_UpdateStatus");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "ISteamMasterServerUpdater_AddMasterServer");
        src_address = dlsym(original_lib_handle, "ISteamMasterServerUpdater_AddMasterServer");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "ISteamMasterServerUpdater_ClearAllKeyValues");
        src_address = dlsym(original_lib_handle, "ISteamMasterServerUpdater_ClearAllKeyValues");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "ISteamMasterServerUpdater_ForceHeartbeat");
        src_address = dlsym(original_lib_handle, "ISteamMasterServerUpdater_ForceHeartbeat");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "ISteamMasterServerUpdater_GetMasterServerAddress");
        src_address = dlsym(original_lib_handle, "ISteamMasterServerUpdater_GetMasterServerAddress");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "ISteamMasterServerUpdater_GetNextOutgoingPacket");
        src_address = dlsym(original_lib_handle, "ISteamMasterServerUpdater_GetNextOutgoingPacket");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "ISteamMasterServerUpdater_GetNumMasterServers");
        src_address = dlsym(original_lib_handle, "ISteamMasterServerUpdater_GetNumMasterServers");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "ISteamMasterServerUpdater_HandleIncomingPacket");
        src_address = dlsym(original_lib_handle, "ISteamMasterServerUpdater_HandleIncomingPacket");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "ISteamMasterServerUpdater_NotifyShutdown");
        src_address = dlsym(original_lib_handle, "ISteamMasterServerUpdater_NotifyShutdown");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "ISteamMasterServerUpdater_RemoveMasterServer");
        src_address = dlsym(original_lib_handle, "ISteamMasterServerUpdater_RemoveMasterServer");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "ISteamMasterServerUpdater_SetActive");
        src_address = dlsym(original_lib_handle, "ISteamMasterServerUpdater_SetActive");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "ISteamMasterServerUpdater_SetBasicServerData");
        src_address = dlsym(original_lib_handle, "ISteamMasterServerUpdater_SetBasicServerData");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "ISteamMasterServerUpdater_SetHeartbeatInterval");
        src_address = dlsym(original_lib_handle, "ISteamMasterServerUpdater_SetHeartbeatInterval");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "ISteamMasterServerUpdater_SetKeyValue");
        src_address = dlsym(original_lib_handle, "ISteamMasterServerUpdater_SetKeyValue");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "ISteamMasterServerUpdater_WasRestartRequested");
        src_address = dlsym(original_lib_handle, "ISteamMasterServerUpdater_WasRestartRequested");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "ISteamUser_BLoggedOn");
        src_address = dlsym(original_lib_handle, "ISteamUser_BLoggedOn");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "ISteamUser_InitiateGameConnection");
        src_address = dlsym(original_lib_handle, "ISteamUser_InitiateGameConnection");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "ISteamUser_TerminateGameConnection");
        src_address = dlsym(original_lib_handle, "ISteamUser_TerminateGameConnection");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "ISteamUtils_GetAppID");
        src_address = dlsym(original_lib_handle, "ISteamUtils_GetAppID");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_GetHSteamPipe");
        src_address = dlsym(original_lib_handle, "SteamAPI_GetHSteamPipe");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_GetHSteamUser");
        src_address = dlsym(original_lib_handle, "SteamAPI_GetHSteamUser");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_GetSteamInstallPath");
        src_address = dlsym(original_lib_handle, "SteamAPI_GetSteamInstallPath");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamAppList_GetAppBuildId");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamAppList_GetAppBuildId");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamAppList_GetAppInstallDir");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamAppList_GetAppInstallDir");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamAppList_GetAppName");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamAppList_GetAppName");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamAppList_GetInstalledApps");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamAppList_GetInstalledApps");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamAppList_GetNumInstalledApps");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamAppList_GetNumInstalledApps");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_BGetDLCDataByIndex");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_BGetDLCDataByIndex");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_BIsAppInstalled");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_BIsAppInstalled");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_BIsCybercafe");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_BIsCybercafe");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_BIsDlcInstalled");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_BIsDlcInstalled");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_BIsLowViolence");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_BIsLowViolence");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_BIsSubscribed");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_BIsSubscribed");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_BIsSubscribedApp");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_BIsSubscribedApp");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_BIsSubscribedFromFamilySharing");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_BIsSubscribedFromFamilySharing");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_BIsSubscribedFromFreeWeekend");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_BIsSubscribedFromFreeWeekend");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_BIsTimedTrial");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_BIsTimedTrial");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_BIsVACBanned");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_BIsVACBanned");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_GetAppBuildId");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_GetAppBuildId");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_GetAppInstallDir");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_GetAppInstallDir");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_GetAppOwner");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_GetAppOwner");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_GetAvailableGameLanguages");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_GetAvailableGameLanguages");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_GetBetaInfo");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_GetBetaInfo");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_GetCurrentBetaName");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_GetCurrentBetaName");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_GetCurrentGameLanguage");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_GetCurrentGameLanguage");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_GetDLCCount");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_GetDLCCount");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_GetDlcDownloadProgress");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_GetDlcDownloadProgress");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_GetEarliestPurchaseUnixTime");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_GetEarliestPurchaseUnixTime");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_GetFileDetails");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_GetFileDetails");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_GetInstalledDepots");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_GetInstalledDepots");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_GetLaunchCommandLine");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_GetLaunchCommandLine");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_GetLaunchQueryParam");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_GetLaunchQueryParam");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_GetNumBetas");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_GetNumBetas");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_GetPublisherOwnedAppData");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_GetPublisherOwnedAppData");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_InstallDLC");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_InstallDLC");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_MarkContentCorrupt");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_MarkContentCorrupt");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_RequestAllProofOfPurchaseKeys");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_RequestAllProofOfPurchaseKeys");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_RequestAppProofOfPurchaseKey");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_RequestAppProofOfPurchaseKey");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_RequestPublisherOwnedAppData");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_RequestPublisherOwnedAppData");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_SetActiveBeta");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_SetActiveBeta");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_SetDlcContext");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_SetDlcContext");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamApps_UninstallDLC");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamApps_UninstallDLC");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_BReleaseSteamPipe");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_BReleaseSteamPipe");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_BShutdownIfAllPipesClosed");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_BShutdownIfAllPipesClosed");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_ConnectToGlobalUser");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_ConnectToGlobalUser");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_CreateLocalUser");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_CreateLocalUser");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_CreateSteamPipe");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_CreateSteamPipe");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_GetIPCCallCount");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_GetIPCCallCount");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_GetISteamAppList");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_GetISteamAppList");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_GetISteamApps");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_GetISteamApps");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_GetISteamController");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_GetISteamController");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_GetISteamFriends");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_GetISteamFriends");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_GetISteamGameSearch");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_GetISteamGameSearch");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_GetISteamGameServer");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_GetISteamGameServer");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_GetISteamGameServerStats");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_GetISteamGameServerStats");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_GetISteamGenericInterface");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_GetISteamGenericInterface");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_GetISteamHTMLSurface");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_GetISteamHTMLSurface");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_GetISteamHTTP");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_GetISteamHTTP");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_GetISteamInput");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_GetISteamInput");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_GetISteamInventory");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_GetISteamInventory");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_GetISteamMatchmaking");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_GetISteamMatchmaking");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_GetISteamMatchmakingServers");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_GetISteamMatchmakingServers");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_GetISteamMusic");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_GetISteamMusic");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_GetISteamMusicRemote");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_GetISteamMusicRemote");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_GetISteamNetworking");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_GetISteamNetworking");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_GetISteamParentalSettings");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_GetISteamParentalSettings");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_GetISteamParties");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_GetISteamParties");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_GetISteamRemotePlay");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_GetISteamRemotePlay");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_GetISteamRemoteStorage");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_GetISteamRemoteStorage");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_GetISteamScreenshots");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_GetISteamScreenshots");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_GetISteamUGC");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_GetISteamUGC");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_GetISteamUnifiedMessages");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_GetISteamUnifiedMessages");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_GetISteamUser");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_GetISteamUser");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_GetISteamUserStats");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_GetISteamUserStats");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_GetISteamUtils");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_GetISteamUtils");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_GetISteamVideo");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_GetISteamVideo");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_ReleaseUser");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_ReleaseUser");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_Remove_SteamAPI_CPostAPIResultInProcess");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_Remove_SteamAPI_CPostAPIResultInProcess");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_RunFrame");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_RunFrame");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_SetLocalIPBinding");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_SetLocalIPBinding");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_SetWarningMessageHook");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_SetWarningMessageHook");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_Set_SteamAPI_CCheckCallbackRegisteredInProcess");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_Set_SteamAPI_CCheckCallbackRegisteredInProcess");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamClient_Set_SteamAPI_CPostAPIResultInProcess");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamClient_Set_SteamAPI_CPostAPIResultInProcess");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_ActivateActionSet");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_ActivateActionSet");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_ActivateActionSetLayer");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_ActivateActionSetLayer");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_DeactivateActionSetLayer");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_DeactivateActionSetLayer");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_DeactivateAllActionSetLayers");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_DeactivateAllActionSetLayers");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_GetActionOriginFromXboxOrigin");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_GetActionOriginFromXboxOrigin");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_GetActionSetHandle");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_GetActionSetHandle");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_GetActiveActionSetLayers");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_GetActiveActionSetLayers");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_GetAnalogActionData");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_GetAnalogActionData");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_GetAnalogActionHandle");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_GetAnalogActionHandle");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_GetAnalogActionOrigins");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_GetAnalogActionOrigins");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_GetConnectedControllers");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_GetConnectedControllers");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_GetControllerBindingRevision");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_GetControllerBindingRevision");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_GetControllerForGamepadIndex");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_GetControllerForGamepadIndex");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_GetControllerState");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_GetControllerState");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_GetCurrentActionSet");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_GetCurrentActionSet");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_GetDigitalActionData");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_GetDigitalActionData");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_GetDigitalActionHandle");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_GetDigitalActionHandle");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_GetDigitalActionOrigins");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_GetDigitalActionOrigins");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_GetGamepadIndexForController");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_GetGamepadIndexForController");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_GetGlyphForActionOrigin");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_GetGlyphForActionOrigin");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_GetGlyphForXboxOrigin");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_GetGlyphForXboxOrigin");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_GetInputTypeForHandle");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_GetInputTypeForHandle");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_GetMotionData");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_GetMotionData");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_GetStringForActionOrigin");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_GetStringForActionOrigin");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_GetStringForXboxOrigin");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_GetStringForXboxOrigin");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_Init");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_Init");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_RunFrame");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_RunFrame");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_SetLEDColor");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_SetLEDColor");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_SetOverrideMode");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_SetOverrideMode");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_ShowAnalogActionOrigins");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_ShowAnalogActionOrigins");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_ShowBindingPanel");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_ShowBindingPanel");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_ShowDigitalActionOrigins");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_ShowDigitalActionOrigins");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_Shutdown");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_Shutdown");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_StopAnalogActionMomentum");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_StopAnalogActionMomentum");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_TranslateActionOrigin");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_TranslateActionOrigin");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_TriggerHapticPulse");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_TriggerHapticPulse");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_TriggerRepeatedHapticPulse");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_TriggerRepeatedHapticPulse");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamController_TriggerVibration");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamController_TriggerVibration");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_ActivateGameOverlay");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_ActivateGameOverlay");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_ActivateGameOverlayInviteDialog");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_ActivateGameOverlayInviteDialog");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_ActivateGameOverlayInviteDialogConnectString");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_ActivateGameOverlayInviteDialogConnectString");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_ActivateGameOverlayRemotePlayTogetherInviteDialog");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_ActivateGameOverlayRemotePlayTogetherInviteDialog");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_ActivateGameOverlayToStore");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_ActivateGameOverlayToStore");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_ActivateGameOverlayToUser");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_ActivateGameOverlayToUser");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_ActivateGameOverlayToWebPage");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_ActivateGameOverlayToWebPage");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_BHasEquippedProfileItem");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_BHasEquippedProfileItem");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_ClearRichPresence");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_ClearRichPresence");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_CloseClanChatWindowInSteam");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_CloseClanChatWindowInSteam");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_DownloadClanActivityCounts");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_DownloadClanActivityCounts");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_EnumerateFollowingList");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_EnumerateFollowingList");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetChatMemberByIndex");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetChatMemberByIndex");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetClanActivityCounts");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetClanActivityCounts");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetClanByIndex");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetClanByIndex");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetClanChatMemberCount");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetClanChatMemberCount");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetClanChatMessage");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetClanChatMessage");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetClanCount");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetClanCount");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetClanName");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetClanName");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetClanOfficerByIndex");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetClanOfficerByIndex");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetClanOfficerCount");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetClanOfficerCount");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetClanOwner");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetClanOwner");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetClanTag");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetClanTag");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetCoplayFriend");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetCoplayFriend");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetCoplayFriendCount");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetCoplayFriendCount");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetFollowerCount");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetFollowerCount");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetFriendByIndex");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetFriendByIndex");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetFriendCoplayGame");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetFriendCoplayGame");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetFriendCoplayTime");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetFriendCoplayTime");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetFriendCount");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetFriendCount");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetFriendCountFromSource");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetFriendCountFromSource");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetFriendFromSourceByIndex");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetFriendFromSourceByIndex");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetFriendGamePlayed");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetFriendGamePlayed");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetFriendMessage");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetFriendMessage");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetFriendPersonaName");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetFriendPersonaName");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetFriendPersonaNameHistory");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetFriendPersonaNameHistory");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetFriendPersonaState");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetFriendPersonaState");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetFriendRelationship");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetFriendRelationship");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetFriendRichPresence");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetFriendRichPresence");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetFriendRichPresenceKeyByIndex");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetFriendRichPresenceKeyByIndex");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetFriendRichPresenceKeyCount");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetFriendRichPresenceKeyCount");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetFriendSteamLevel");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetFriendSteamLevel");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetFriendsGroupCount");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetFriendsGroupCount");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetFriendsGroupIDByIndex");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetFriendsGroupIDByIndex");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetFriendsGroupMembersCount");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetFriendsGroupMembersCount");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetFriendsGroupMembersList");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetFriendsGroupMembersList");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetFriendsGroupName");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetFriendsGroupName");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetLargeFriendAvatar");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetLargeFriendAvatar");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetMediumFriendAvatar");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetMediumFriendAvatar");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetNumChatsWithUnreadPriorityMessages");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetNumChatsWithUnreadPriorityMessages");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetPersonaName");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetPersonaName");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetPersonaState");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetPersonaState");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetPlayerNickname");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetPlayerNickname");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetProfileItemPropertyString");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetProfileItemPropertyString");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetProfileItemPropertyUint");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetProfileItemPropertyUint");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetSmallFriendAvatar");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetSmallFriendAvatar");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_GetUserRestrictions");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_GetUserRestrictions");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_HasFriend");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_HasFriend");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_InviteUserToGame");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_InviteUserToGame");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_IsClanChatAdmin");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_IsClanChatAdmin");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_IsClanChatWindowOpenInSteam");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_IsClanChatWindowOpenInSteam");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_IsClanOfficialGameGroup");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_IsClanOfficialGameGroup");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_IsClanPublic");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_IsClanPublic");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_IsFollowing");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_IsFollowing");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_IsUserInSource");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_IsUserInSource");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_JoinClanChatRoom");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_JoinClanChatRoom");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_LeaveClanChatRoom");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_LeaveClanChatRoom");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_OpenClanChatWindowInSteam");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_OpenClanChatWindowInSteam");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_RegisterProtocolInOverlayBrowser");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_RegisterProtocolInOverlayBrowser");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_ReplyToFriendMessage");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_ReplyToFriendMessage");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_RequestClanOfficerList");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_RequestClanOfficerList");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_RequestEquippedProfileItems");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_RequestEquippedProfileItems");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_RequestFriendRichPresence");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_RequestFriendRichPresence");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_RequestUserInformation");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_RequestUserInformation");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_SendClanChatMessage");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_SendClanChatMessage");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_SetInGameVoiceSpeaking");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_SetInGameVoiceSpeaking");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_SetListenForFriendsMessages");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_SetListenForFriendsMessages");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_SetPersonaName");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_SetPersonaName");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_SetPlayedWith");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_SetPlayedWith");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamFriends_SetRichPresence");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamFriends_SetRichPresence");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameSearch_AcceptGame");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameSearch_AcceptGame");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameSearch_AddGameSearchParams");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameSearch_AddGameSearchParams");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameSearch_CancelRequestPlayersForGame");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameSearch_CancelRequestPlayersForGame");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameSearch_DeclineGame");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameSearch_DeclineGame");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameSearch_EndGame");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameSearch_EndGame");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameSearch_EndGameSearch");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameSearch_EndGameSearch");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameSearch_HostConfirmGameStart");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameSearch_HostConfirmGameStart");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameSearch_RequestPlayersForGame");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameSearch_RequestPlayersForGame");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameSearch_RetrieveConnectionDetails");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameSearch_RetrieveConnectionDetails");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameSearch_SearchForGameSolo");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameSearch_SearchForGameSolo");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameSearch_SearchForGameWithLobby");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameSearch_SearchForGameWithLobby");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameSearch_SetConnectionDetails");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameSearch_SetConnectionDetails");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameSearch_SetGameHostParams");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameSearch_SetGameHostParams");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameSearch_SubmitPlayerResult");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameSearch_SubmitPlayerResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServerStats_ClearUserAchievement");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServerStats_ClearUserAchievement");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServerStats_GetUserAchievement");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServerStats_GetUserAchievement");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServerStats_GetUserStat");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServerStats_GetUserStat");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServerStats_GetUserStat0");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServerStats_GetUserStat0");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServerStats_GetUserStatFloat");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServerStats_GetUserStatFloat");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServerStats_GetUserStatInt32");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServerStats_GetUserStatInt32");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServerStats_RequestUserStats");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServerStats_RequestUserStats");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServerStats_SetUserAchievement");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServerStats_SetUserAchievement");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServerStats_SetUserStat");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServerStats_SetUserStat");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServerStats_SetUserStat0");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServerStats_SetUserStat0");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServerStats_SetUserStatFloat");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServerStats_SetUserStatFloat");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServerStats_SetUserStatInt32");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServerStats_SetUserStatInt32");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServerStats_StoreUserStats");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServerStats_StoreUserStats");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServerStats_UpdateUserAvgRateStat");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServerStats_UpdateUserAvgRateStat");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_AssociateWithClan");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_AssociateWithClan");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_BLoggedOn");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_BLoggedOn");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_BSecure");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_BSecure");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_BUpdateUserData");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_BUpdateUserData");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_BeginAuthSession");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_BeginAuthSession");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_CancelAuthTicket");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_CancelAuthTicket");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_ClearAllKeyValues");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_ClearAllKeyValues");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_ComputeNewPlayerCompatibility");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_ComputeNewPlayerCompatibility");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_CreateUnauthenticatedUserConnection");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_CreateUnauthenticatedUserConnection");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_EnableHeartbeats");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_EnableHeartbeats");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_EndAuthSession");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_EndAuthSession");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_ForceHeartbeat");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_ForceHeartbeat");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_GetAuthSessionTicket");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_GetAuthSessionTicket");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_GetGameplayStats");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_GetGameplayStats");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_GetNextOutgoingPacket");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_GetNextOutgoingPacket");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_GetPublicIP");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_GetPublicIP");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_GetServerReputation");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_GetServerReputation");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_GetSteamID");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_GetSteamID");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_HandleIncomingPacket");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_HandleIncomingPacket");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_InitGameServer");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_InitGameServer");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_LogOff");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_LogOff");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_LogOn");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_LogOn");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_LogOnAnonymous");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_LogOnAnonymous");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_RequestUserGroupStatus");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_RequestUserGroupStatus");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_SendUserConnectAndAuthenticate");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_SendUserConnectAndAuthenticate");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_SendUserConnectAndAuthenticate_DEPRECATED");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_SendUserConnectAndAuthenticate_DEPRECATED");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_SendUserDisconnect");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_SendUserDisconnect");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_SendUserDisconnect_DEPRECATED");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_SendUserDisconnect_DEPRECATED");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_SetAdvertiseServerActive");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_SetAdvertiseServerActive");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_SetBotPlayerCount");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_SetBotPlayerCount");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_SetDedicatedServer");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_SetDedicatedServer");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_SetGameData");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_SetGameData");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_SetGameDescription");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_SetGameDescription");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_SetGameTags");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_SetGameTags");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_SetHeartbeatInterval");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_SetHeartbeatInterval");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_SetKeyValue");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_SetKeyValue");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_SetMapName");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_SetMapName");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_SetMaxPlayerCount");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_SetMaxPlayerCount");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_SetModDir");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_SetModDir");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_SetPasswordProtected");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_SetPasswordProtected");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_SetProduct");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_SetProduct");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_SetRegion");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_SetRegion");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_SetServerName");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_SetServerName");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_SetSpectatorPort");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_SetSpectatorPort");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_SetSpectatorServerName");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_SetSpectatorServerName");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_UserHasLicenseForApp");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_UserHasLicenseForApp");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamGameServer_WasRestartRequested");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamGameServer_WasRestartRequested");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_AddHeader");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_AddHeader");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_AllowStartRequest");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_AllowStartRequest");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_CopyToClipboard");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_CopyToClipboard");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_CreateBrowser");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_CreateBrowser");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_DestructISteamHTMLSurface");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_DestructISteamHTMLSurface");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_ExecuteJavascript");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_ExecuteJavascript");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_FileLoadDialogResponse");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_FileLoadDialogResponse");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_Find");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_Find");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_GetLinkAtPosition");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_GetLinkAtPosition");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_GoBack");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_GoBack");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_GoForward");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_GoForward");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_Init");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_Init");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_JSDialogResponse");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_JSDialogResponse");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_KeyChar");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_KeyChar");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_KeyDown");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_KeyDown");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_KeyUp");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_KeyUp");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_LoadURL");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_LoadURL");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_MouseDoubleClick");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_MouseDoubleClick");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_MouseDown");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_MouseDown");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_MouseMove");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_MouseMove");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_MouseUp");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_MouseUp");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_MouseWheel");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_MouseWheel");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_OpenDeveloperTools");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_OpenDeveloperTools");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_PasteFromClipboard");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_PasteFromClipboard");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_Reload");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_Reload");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_RemoveBrowser");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_RemoveBrowser");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_SetBackgroundMode");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_SetBackgroundMode");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_SetCookie");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_SetCookie");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_SetDPIScalingFactor");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_SetDPIScalingFactor");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_SetHorizontalScroll");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_SetHorizontalScroll");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_SetKeyFocus");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_SetKeyFocus");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_SetPageScaleFactor");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_SetPageScaleFactor");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_SetSize");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_SetSize");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_SetVerticalScroll");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_SetVerticalScroll");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_Shutdown");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_Shutdown");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_StopFind");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_StopFind");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_StopLoad");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_StopLoad");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTMLSurface_ViewSource");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTMLSurface_ViewSource");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTTP_CreateCookieContainer");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTTP_CreateCookieContainer");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTTP_CreateHTTPRequest");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTTP_CreateHTTPRequest");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTTP_DeferHTTPRequest");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTTP_DeferHTTPRequest");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTTP_GetHTTPDownloadProgressPct");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTTP_GetHTTPDownloadProgressPct");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTTP_GetHTTPRequestWasTimedOut");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTTP_GetHTTPRequestWasTimedOut");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTTP_GetHTTPResponseBodyData");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTTP_GetHTTPResponseBodyData");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTTP_GetHTTPResponseBodySize");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTTP_GetHTTPResponseBodySize");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTTP_GetHTTPResponseHeaderSize");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTTP_GetHTTPResponseHeaderSize");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTTP_GetHTTPResponseHeaderValue");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTTP_GetHTTPResponseHeaderValue");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTTP_GetHTTPStreamingResponseBodyData");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTTP_GetHTTPStreamingResponseBodyData");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTTP_PrioritizeHTTPRequest");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTTP_PrioritizeHTTPRequest");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTTP_ReleaseCookieContainer");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTTP_ReleaseCookieContainer");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTTP_ReleaseHTTPRequest");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTTP_ReleaseHTTPRequest");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTTP_SendHTTPRequest");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTTP_SendHTTPRequest");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTTP_SendHTTPRequestAndStreamResponse");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTTP_SendHTTPRequestAndStreamResponse");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTTP_SetCookie");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTTP_SetCookie");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTTP_SetHTTPRequestAbsoluteTimeoutMS");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTTP_SetHTTPRequestAbsoluteTimeoutMS");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTTP_SetHTTPRequestContextValue");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTTP_SetHTTPRequestContextValue");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTTP_SetHTTPRequestCookieContainer");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTTP_SetHTTPRequestCookieContainer");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTTP_SetHTTPRequestGetOrPostParameter");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTTP_SetHTTPRequestGetOrPostParameter");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTTP_SetHTTPRequestHeaderValue");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTTP_SetHTTPRequestHeaderValue");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTTP_SetHTTPRequestNetworkActivityTimeout");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTTP_SetHTTPRequestNetworkActivityTimeout");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTTP_SetHTTPRequestRawPostBody");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTTP_SetHTTPRequestRawPostBody");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTTP_SetHTTPRequestRequiresVerifiedCertificate");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTTP_SetHTTPRequestRequiresVerifiedCertificate");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamHTTP_SetHTTPRequestUserAgentInfo");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamHTTP_SetHTTPRequestUserAgentInfo");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_ActivateActionSet");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_ActivateActionSet");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_ActivateActionSetLayer");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_ActivateActionSetLayer");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_BNewDataAvailable");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_BNewDataAvailable");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_BWaitForData");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_BWaitForData");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_DeactivateActionSetLayer");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_DeactivateActionSetLayer");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_DeactivateAllActionSetLayers");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_DeactivateAllActionSetLayers");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_EnableActionEventCallbacks");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_EnableActionEventCallbacks");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_EnableDeviceCallbacks");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_EnableDeviceCallbacks");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_GetActionOriginFromXboxOrigin");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_GetActionOriginFromXboxOrigin");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_GetActionSetHandle");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_GetActionSetHandle");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_GetActiveActionSetLayers");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_GetActiveActionSetLayers");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_GetAnalogActionData");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_GetAnalogActionData");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_GetAnalogActionHandle");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_GetAnalogActionHandle");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_GetAnalogActionOrigins");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_GetAnalogActionOrigins");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_GetConnectedControllers");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_GetConnectedControllers");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_GetControllerForGamepadIndex");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_GetControllerForGamepadIndex");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_GetCurrentActionSet");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_GetCurrentActionSet");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_GetDeviceBindingRevision");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_GetDeviceBindingRevision");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_GetDigitalActionData");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_GetDigitalActionData");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_GetDigitalActionHandle");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_GetDigitalActionHandle");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_GetDigitalActionOrigins");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_GetDigitalActionOrigins");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_GetGamepadIndexForController");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_GetGamepadIndexForController");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_GetGlyphForActionOrigin");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_GetGlyphForActionOrigin");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_GetGlyphForActionOrigin_Legacy");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_GetGlyphForActionOrigin_Legacy");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_GetGlyphForXboxOrigin");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_GetGlyphForXboxOrigin");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_GetGlyphPNGForActionOrigin");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_GetGlyphPNGForActionOrigin");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_GetGlyphSVGForActionOrigin");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_GetGlyphSVGForActionOrigin");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_GetInputTypeForHandle");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_GetInputTypeForHandle");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_GetMotionData");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_GetMotionData");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_GetRemotePlaySessionID");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_GetRemotePlaySessionID");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_GetSessionInputConfigurationSettings");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_GetSessionInputConfigurationSettings");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_GetStringForActionOrigin");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_GetStringForActionOrigin");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_GetStringForAnalogActionName");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_GetStringForAnalogActionName");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_GetStringForDigitalActionName");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_GetStringForDigitalActionName");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_GetStringForXboxOrigin");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_GetStringForXboxOrigin");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_Init");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_Init");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_Legacy_TriggerHapticPulse");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_Legacy_TriggerHapticPulse");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_Legacy_TriggerRepeatedHapticPulse");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_Legacy_TriggerRepeatedHapticPulse");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_RunFrame");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_RunFrame");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_SetDualSenseTriggerEffect");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_SetDualSenseTriggerEffect");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_SetInputActionManifestFilePath");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_SetInputActionManifestFilePath");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_SetLEDColor");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_SetLEDColor");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_ShowBindingPanel");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_ShowBindingPanel");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_Shutdown");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_Shutdown");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_StopAnalogActionMomentum");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_StopAnalogActionMomentum");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_TranslateActionOrigin");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_TranslateActionOrigin");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_TriggerHapticPulse");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_TriggerHapticPulse");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_TriggerRepeatedHapticPulse");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_TriggerRepeatedHapticPulse");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_TriggerSimpleHapticEvent");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_TriggerSimpleHapticEvent");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_TriggerVibration");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_TriggerVibration");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInput_TriggerVibrationExtended");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInput_TriggerVibrationExtended");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_AddPromoItem");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_AddPromoItem");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_AddPromoItems");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_AddPromoItems");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_CheckResultSteamID");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_CheckResultSteamID");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_ConsumeItem");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_ConsumeItem");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_DeserializeResult");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_DeserializeResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_DestroyResult");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_DestroyResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_ExchangeItems");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_ExchangeItems");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_GenerateItems");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_GenerateItems");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_GetAllItems");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_GetAllItems");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_GetEligiblePromoItemDefinitionIDs");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_GetEligiblePromoItemDefinitionIDs");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_GetItemDefinitionIDs");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_GetItemDefinitionIDs");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_GetItemDefinitionProperty");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_GetItemDefinitionProperty");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_GetItemPrice");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_GetItemPrice");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_GetItemsByID");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_GetItemsByID");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_GetItemsWithPrices");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_GetItemsWithPrices");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_GetNumItemsWithPrices");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_GetNumItemsWithPrices");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_GetResultItemProperty");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_GetResultItemProperty");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_GetResultItems");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_GetResultItems");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_GetResultStatus");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_GetResultStatus");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_GetResultTimestamp");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_GetResultTimestamp");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_GrantPromoItems");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_GrantPromoItems");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_InspectItem");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_InspectItem");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_LoadItemDefinitions");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_LoadItemDefinitions");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_RemoveProperty");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_RemoveProperty");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_RequestEligiblePromoItemDefinitionsIDs");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_RequestEligiblePromoItemDefinitionsIDs");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_RequestPrices");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_RequestPrices");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_SendItemDropHeartbeat");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_SendItemDropHeartbeat");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_SerializeResult");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_SerializeResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_SetProperty");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_SetProperty");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_SetProperty0");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_SetProperty0");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_SetProperty1");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_SetProperty1");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_SetProperty2");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_SetProperty2");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_SetPropertyBool");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_SetPropertyBool");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_SetPropertyFloat");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_SetPropertyFloat");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_SetPropertyInt64");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_SetPropertyInt64");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_SetPropertyString");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_SetPropertyString");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_StartPurchase");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_StartPurchase");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_StartUpdateProperties");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_StartUpdateProperties");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_SubmitUpdateProperties");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_SubmitUpdateProperties");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_TradeItems");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_TradeItems");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_TransferItemQuantity");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_TransferItemQuantity");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamInventory_TriggerItemDrop");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamInventory_TriggerItemDrop");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmakingPingResponse_ServerFailedToRespond");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmakingPingResponse_ServerFailedToRespond");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmakingPingResponse_ServerResponded");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmakingPingResponse_ServerResponded");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmakingPlayersResponse_AddPlayerToList");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmakingPlayersResponse_AddPlayerToList");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmakingPlayersResponse_PlayersFailedToRespond");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmakingPlayersResponse_PlayersFailedToRespond");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmakingPlayersResponse_PlayersRefreshComplete");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmakingPlayersResponse_PlayersRefreshComplete");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmakingRulesResponse_RulesFailedToRespond");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmakingRulesResponse_RulesFailedToRespond");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmakingRulesResponse_RulesRefreshComplete");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmakingRulesResponse_RulesRefreshComplete");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmakingRulesResponse_RulesResponded");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmakingRulesResponse_RulesResponded");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmakingServerListResponse_RefreshComplete");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmakingServerListResponse_RefreshComplete");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmakingServerListResponse_ServerFailedToRespond");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmakingServerListResponse_ServerFailedToRespond");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmakingServerListResponse_ServerResponded");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmakingServerListResponse_ServerResponded");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmakingServers_CancelQuery");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmakingServers_CancelQuery");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmakingServers_CancelServerQuery");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmakingServers_CancelServerQuery");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmakingServers_GetServerCount");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmakingServers_GetServerCount");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmakingServers_GetServerDetails");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmakingServers_GetServerDetails");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmakingServers_IsRefreshing");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmakingServers_IsRefreshing");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmakingServers_PingServer");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmakingServers_PingServer");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmakingServers_PlayerDetails");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmakingServers_PlayerDetails");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmakingServers_RefreshQuery");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmakingServers_RefreshQuery");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmakingServers_RefreshServer");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmakingServers_RefreshServer");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmakingServers_ReleaseRequest");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmakingServers_ReleaseRequest");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmakingServers_RequestFavoritesServerList");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmakingServers_RequestFavoritesServerList");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmakingServers_RequestFriendsServerList");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmakingServers_RequestFriendsServerList");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmakingServers_RequestHistoryServerList");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmakingServers_RequestHistoryServerList");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmakingServers_RequestInternetServerList");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmakingServers_RequestInternetServerList");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmakingServers_RequestLANServerList");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmakingServers_RequestLANServerList");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmakingServers_RequestSpectatorServerList");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmakingServers_RequestSpectatorServerList");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmakingServers_ServerRules");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmakingServers_ServerRules");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_AddFavoriteGame");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_AddFavoriteGame");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_AddRequestLobbyListCompatibleMembersFilter");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_AddRequestLobbyListCompatibleMembersFilter");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_AddRequestLobbyListDistanceFilter");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_AddRequestLobbyListDistanceFilter");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_AddRequestLobbyListFilterSlotsAvailable");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_AddRequestLobbyListFilterSlotsAvailable");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_AddRequestLobbyListNearValueFilter");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_AddRequestLobbyListNearValueFilter");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_AddRequestLobbyListNumericalFilter");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_AddRequestLobbyListNumericalFilter");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_AddRequestLobbyListResultCountFilter");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_AddRequestLobbyListResultCountFilter");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_AddRequestLobbyListStringFilter");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_AddRequestLobbyListStringFilter");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_CreateLobby");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_CreateLobby");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_DeleteLobbyData");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_DeleteLobbyData");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_GetFavoriteGame");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_GetFavoriteGame");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_GetFavoriteGameCount");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_GetFavoriteGameCount");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_GetLobbyByIndex");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_GetLobbyByIndex");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_GetLobbyChatEntry");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_GetLobbyChatEntry");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_GetLobbyData");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_GetLobbyData");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_GetLobbyDataByIndex");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_GetLobbyDataByIndex");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_GetLobbyDataCount");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_GetLobbyDataCount");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_GetLobbyGameServer");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_GetLobbyGameServer");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_GetLobbyMemberByIndex");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_GetLobbyMemberByIndex");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_GetLobbyMemberData");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_GetLobbyMemberData");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_GetLobbyMemberLimit");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_GetLobbyMemberLimit");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_GetLobbyOwner");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_GetLobbyOwner");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_GetNumLobbyMembers");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_GetNumLobbyMembers");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_InviteUserToLobby");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_InviteUserToLobby");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_JoinLobby");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_JoinLobby");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_LeaveLobby");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_LeaveLobby");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_RemoveFavoriteGame");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_RemoveFavoriteGame");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_RequestLobbyData");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_RequestLobbyData");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_RequestLobbyList");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_RequestLobbyList");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_SendLobbyChatMsg");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_SendLobbyChatMsg");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_SetLinkedLobby");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_SetLinkedLobby");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_SetLobbyData");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_SetLobbyData");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_SetLobbyGameServer");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_SetLobbyGameServer");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_SetLobbyJoinable");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_SetLobbyJoinable");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_SetLobbyMemberData");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_SetLobbyMemberData");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_SetLobbyMemberLimit");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_SetLobbyMemberLimit");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_SetLobbyOwner");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_SetLobbyOwner");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMatchmaking_SetLobbyType");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMatchmaking_SetLobbyType");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusicRemote_BActivationSuccess");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusicRemote_BActivationSuccess");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusicRemote_BIsCurrentMusicRemote");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusicRemote_BIsCurrentMusicRemote");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusicRemote_CurrentEntryDidChange");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusicRemote_CurrentEntryDidChange");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusicRemote_CurrentEntryIsAvailable");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusicRemote_CurrentEntryIsAvailable");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusicRemote_CurrentEntryWillChange");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusicRemote_CurrentEntryWillChange");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusicRemote_DeregisterSteamMusicRemote");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusicRemote_DeregisterSteamMusicRemote");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusicRemote_EnableLooped");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusicRemote_EnableLooped");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusicRemote_EnablePlayNext");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusicRemote_EnablePlayNext");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusicRemote_EnablePlayPrevious");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusicRemote_EnablePlayPrevious");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusicRemote_EnablePlaylists");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusicRemote_EnablePlaylists");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusicRemote_EnableQueue");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusicRemote_EnableQueue");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusicRemote_EnableShuffled");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusicRemote_EnableShuffled");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusicRemote_PlaylistDidChange");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusicRemote_PlaylistDidChange");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusicRemote_PlaylistWillChange");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusicRemote_PlaylistWillChange");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusicRemote_QueueDidChange");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusicRemote_QueueDidChange");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusicRemote_QueueWillChange");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusicRemote_QueueWillChange");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusicRemote_RegisterSteamMusicRemote");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusicRemote_RegisterSteamMusicRemote");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusicRemote_ResetPlaylistEntries");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusicRemote_ResetPlaylistEntries");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusicRemote_ResetQueueEntries");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusicRemote_ResetQueueEntries");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusicRemote_SetCurrentPlaylistEntry");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusicRemote_SetCurrentPlaylistEntry");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusicRemote_SetCurrentQueueEntry");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusicRemote_SetCurrentQueueEntry");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusicRemote_SetDisplayName");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusicRemote_SetDisplayName");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusicRemote_SetPNGIcon_64x64");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusicRemote_SetPNGIcon_64x64");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusicRemote_SetPlaylistEntry");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusicRemote_SetPlaylistEntry");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusicRemote_SetQueueEntry");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusicRemote_SetQueueEntry");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusicRemote_UpdateCurrentEntryCoverArt");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusicRemote_UpdateCurrentEntryCoverArt");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusicRemote_UpdateCurrentEntryElapsedSeconds");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusicRemote_UpdateCurrentEntryElapsedSeconds");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusicRemote_UpdateCurrentEntryText");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusicRemote_UpdateCurrentEntryText");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusicRemote_UpdateLooped");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusicRemote_UpdateLooped");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusicRemote_UpdatePlaybackStatus");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusicRemote_UpdatePlaybackStatus");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusicRemote_UpdateShuffled");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusicRemote_UpdateShuffled");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusicRemote_UpdateVolume");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusicRemote_UpdateVolume");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusic_BIsEnabled");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusic_BIsEnabled");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusic_BIsPlaying");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusic_BIsPlaying");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusic_GetPlaybackStatus");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusic_GetPlaybackStatus");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusic_GetVolume");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusic_GetVolume");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusic_Pause");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusic_Pause");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusic_Play");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusic_Play");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusic_PlayNext");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusic_PlayNext");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusic_PlayPrevious");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusic_PlayPrevious");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamMusic_SetVolume");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamMusic_SetVolume");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingConnectionCustomSignaling_Release");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingConnectionCustomSignaling_Release");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingConnectionCustomSignaling_SendSignal");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingConnectionCustomSignaling_SendSignal");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingCustomSignalingRecvContext_OnConnectRequest");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingCustomSignalingRecvContext_OnConnectRequest");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingCustomSignalingRecvContext_SendRejectionSignal");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingCustomSignalingRecvContext_SendRejectionSignal");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingFakeUDPPort_DestroyFakeUDPPort");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingFakeUDPPort_DestroyFakeUDPPort");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingFakeUDPPort_ReceiveMessages");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingFakeUDPPort_ReceiveMessages");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingFakeUDPPort_ScheduleCleanup");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingFakeUDPPort_ScheduleCleanup");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingFakeUDPPort_SendMessageToFakeIP");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingFakeUDPPort_SendMessageToFakeIP");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingMessages_AcceptSessionWithUser");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingMessages_AcceptSessionWithUser");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingMessages_CloseChannelWithUser");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingMessages_CloseChannelWithUser");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingMessages_CloseSessionWithUser");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingMessages_CloseSessionWithUser");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingMessages_GetSessionConnectionInfo");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingMessages_GetSessionConnectionInfo");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingMessages_ReceiveMessagesOnChannel");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingMessages_ReceiveMessagesOnChannel");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingMessages_SendMessageToUser");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingMessages_SendMessageToUser");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_AcceptConnection");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_AcceptConnection");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_BeginAsyncRequestFakeIP");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_BeginAsyncRequestFakeIP");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_CloseConnection");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_CloseConnection");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_CloseListenSocket");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_CloseListenSocket");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_ConfigureConnectionLanes");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_ConfigureConnectionLanes");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_ConnectByIPAddress");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_ConnectByIPAddress");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_ConnectP2P");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_ConnectP2P");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_ConnectP2PCustomSignaling");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_ConnectP2PCustomSignaling");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_ConnectToHostedDedicatedServer");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_ConnectToHostedDedicatedServer");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_CreateFakeUDPPort");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_CreateFakeUDPPort");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_CreateHostedDedicatedServerListenSocket");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_CreateHostedDedicatedServerListenSocket");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_CreateListenSocketIP");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_CreateListenSocketIP");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_CreateListenSocketP2P");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_CreateListenSocketP2P");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_CreateListenSocketP2PFakeIP");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_CreateListenSocketP2PFakeIP");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_CreatePollGroup");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_CreatePollGroup");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_CreateSocketPair");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_CreateSocketPair");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_DestroyPollGroup");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_DestroyPollGroup");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_FindRelayAuthTicketForServer");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_FindRelayAuthTicketForServer");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_FlushMessagesOnConnection");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_FlushMessagesOnConnection");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_GetAuthenticationStatus");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_GetAuthenticationStatus");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_GetCertificateRequest");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_GetCertificateRequest");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_GetConnectionInfo");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_GetConnectionInfo");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_GetConnectionName");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_GetConnectionName");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_GetConnectionRealTimeStatus");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_GetConnectionRealTimeStatus");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_GetConnectionUserData");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_GetConnectionUserData");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_GetDetailedConnectionStatus");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_GetDetailedConnectionStatus");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_GetFakeIP");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_GetFakeIP");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_GetGameCoordinatorServerLogin");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_GetGameCoordinatorServerLogin");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_GetHostedDedicatedServerAddress");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_GetHostedDedicatedServerAddress");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_GetHostedDedicatedServerPOPID");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_GetHostedDedicatedServerPOPID");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_GetHostedDedicatedServerPort");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_GetHostedDedicatedServerPort");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_GetIdentity");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_GetIdentity");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_GetListenSocketAddress");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_GetListenSocketAddress");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_GetQuickConnectionStatus");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_GetQuickConnectionStatus");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_GetRemoteFakeIPForConnection");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_GetRemoteFakeIPForConnection");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_InitAuthentication");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_InitAuthentication");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_ReceiveMessagesOnConnection");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_ReceiveMessagesOnConnection");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_ReceiveMessagesOnPollGroup");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_ReceiveMessagesOnPollGroup");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_ReceivedP2PCustomSignal");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_ReceivedP2PCustomSignal");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_ReceivedRelayAuthTicket");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_ReceivedRelayAuthTicket");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_ResetIdentity");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_ResetIdentity");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_RunCallbacks");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_RunCallbacks");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_SendMessageToConnection");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_SendMessageToConnection");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_SendMessages");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_SendMessages");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_SetCertificate");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_SetCertificate");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_SetConnectionName");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_SetConnectionName");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_SetConnectionPollGroup");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_SetConnectionPollGroup");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingSockets_SetConnectionUserData");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingSockets_SetConnectionUserData");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_AllocateMessage");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_AllocateMessage");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_CheckPingDataUpToDate");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_CheckPingDataUpToDate");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_ConvertPingLocationToString");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_ConvertPingLocationToString");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_EstimatePingTimeBetweenTwoLocations");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_EstimatePingTimeBetweenTwoLocations");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_EstimatePingTimeFromLocalHost");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_EstimatePingTimeFromLocalHost");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_GetConfigValue");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_GetConfigValue");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_GetConfigValueInfo");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_GetConfigValueInfo");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_GetDirectPingToPOP");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_GetDirectPingToPOP");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_GetFirstConfigValue");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_GetFirstConfigValue");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_GetIPv4FakeIPType");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_GetIPv4FakeIPType");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_GetLocalPingLocation");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_GetLocalPingLocation");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_GetLocalTimestamp");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_GetLocalTimestamp");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_GetPOPCount");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_GetPOPCount");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_GetPOPList");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_GetPOPList");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_GetPingToDataCenter");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_GetPingToDataCenter");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_GetRealIdentityForFakeIP");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_GetRealIdentityForFakeIP");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_GetRelayNetworkStatus");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_GetRelayNetworkStatus");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_InitRelayNetworkAccess");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_InitRelayNetworkAccess");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_IsFakeIPv4");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_IsFakeIPv4");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_IterateGenericEditableConfigValues");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_IterateGenericEditableConfigValues");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_ParsePingLocationString");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_ParsePingLocationString");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_SetConfigValue");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_SetConfigValue");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_SetConfigValueStruct");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_SetConfigValueStruct");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_SetConnectionConfigValueFloat");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_SetConnectionConfigValueFloat");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_SetConnectionConfigValueInt32");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_SetConnectionConfigValueInt32");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_SetConnectionConfigValueString");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_SetConnectionConfigValueString");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_SetDebugOutputFunction");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_SetDebugOutputFunction");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_FakeIPResult");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_FakeIPResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_MessagesSessionFailed");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_MessagesSessionFailed");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_MessagesSessionRequest");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_MessagesSessionRequest");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_SteamNetAuthenticationStatusChanged");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_SteamNetAuthenticationStatusChanged");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_SteamNetConnectionStatusChanged");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_SteamNetConnectionStatusChanged");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_SteamRelayNetworkStatusChanged");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_SetGlobalCallback_SteamRelayNetworkStatusChanged");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_SetGlobalConfigValueFloat");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_SetGlobalConfigValueFloat");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_SetGlobalConfigValueInt32");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_SetGlobalConfigValueInt32");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_SetGlobalConfigValuePtr");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_SetGlobalConfigValuePtr");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_SetGlobalConfigValueString");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_SetGlobalConfigValueString");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_SteamNetworkingIPAddr_GetFakeIPType");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_SteamNetworkingIPAddr_GetFakeIPType");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_SteamNetworkingIPAddr_ParseString");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_SteamNetworkingIPAddr_ParseString");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_SteamNetworkingIPAddr_ToString");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_SteamNetworkingIPAddr_ToString");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_SteamNetworkingIdentity_ParseString");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_SteamNetworkingIdentity_ParseString");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworkingUtils_SteamNetworkingIdentity_ToString");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworkingUtils_SteamNetworkingIdentity_ToString");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworking_AcceptP2PSessionWithUser");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworking_AcceptP2PSessionWithUser");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworking_AllowP2PPacketRelay");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworking_AllowP2PPacketRelay");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworking_CloseP2PChannelWithUser");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworking_CloseP2PChannelWithUser");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworking_CloseP2PSessionWithUser");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworking_CloseP2PSessionWithUser");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworking_CreateConnectionSocket");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworking_CreateConnectionSocket");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworking_CreateListenSocket");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworking_CreateListenSocket");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworking_CreateP2PConnectionSocket");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworking_CreateP2PConnectionSocket");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworking_DestroyListenSocket");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworking_DestroyListenSocket");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworking_DestroySocket");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworking_DestroySocket");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworking_GetListenSocketInfo");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworking_GetListenSocketInfo");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworking_GetMaxPacketSize");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworking_GetMaxPacketSize");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworking_GetP2PSessionState");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworking_GetP2PSessionState");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworking_GetSocketConnectionType");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworking_GetSocketConnectionType");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworking_GetSocketInfo");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworking_GetSocketInfo");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworking_IsDataAvailable");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworking_IsDataAvailable");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworking_IsDataAvailableOnSocket");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworking_IsDataAvailableOnSocket");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworking_IsP2PPacketAvailable");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworking_IsP2PPacketAvailable");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworking_ReadP2PPacket");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworking_ReadP2PPacket");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworking_RetrieveData");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworking_RetrieveData");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworking_RetrieveDataFromSocket");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworking_RetrieveDataFromSocket");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworking_SendDataOnSocket");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworking_SendDataOnSocket");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamNetworking_SendP2PPacket");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamNetworking_SendP2PPacket");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamParentalSettings_BIsAppBlocked");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamParentalSettings_BIsAppBlocked");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamParentalSettings_BIsAppInBlockList");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamParentalSettings_BIsAppInBlockList");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamParentalSettings_BIsFeatureBlocked");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamParentalSettings_BIsFeatureBlocked");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamParentalSettings_BIsFeatureInBlockList");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamParentalSettings_BIsFeatureInBlockList");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamParentalSettings_BIsParentalLockEnabled");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamParentalSettings_BIsParentalLockEnabled");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamParentalSettings_BIsParentalLockLocked");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamParentalSettings_BIsParentalLockLocked");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamParties_CancelReservation");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamParties_CancelReservation");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamParties_ChangeNumOpenSlots");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamParties_ChangeNumOpenSlots");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamParties_CreateBeacon");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamParties_CreateBeacon");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamParties_DestroyBeacon");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamParties_DestroyBeacon");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamParties_GetAvailableBeaconLocations");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamParties_GetAvailableBeaconLocations");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamParties_GetBeaconByIndex");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamParties_GetBeaconByIndex");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamParties_GetBeaconDetails");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamParties_GetBeaconDetails");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamParties_GetBeaconLocationData");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamParties_GetBeaconLocationData");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamParties_GetNumActiveBeacons");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamParties_GetNumActiveBeacons");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamParties_GetNumAvailableBeaconLocations");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamParties_GetNumAvailableBeaconLocations");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamParties_JoinParty");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamParties_JoinParty");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamParties_OnReservationCompleted");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamParties_OnReservationCompleted");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemotePlay_BEnableRemotePlayTogetherDirectInput");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemotePlay_BEnableRemotePlayTogetherDirectInput");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemotePlay_BGetSessionClientResolution");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemotePlay_BGetSessionClientResolution");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemotePlay_BSendRemotePlayTogetherInvite");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemotePlay_BSendRemotePlayTogetherInvite");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemotePlay_BStartRemotePlayTogether");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemotePlay_BStartRemotePlayTogether");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemotePlay_CreateMouseCursor");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemotePlay_CreateMouseCursor");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemotePlay_DisableRemotePlayTogetherDirectInput");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemotePlay_DisableRemotePlayTogetherDirectInput");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemotePlay_GetInput");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemotePlay_GetInput");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemotePlay_GetSessionClientFormFactor");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemotePlay_GetSessionClientFormFactor");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemotePlay_GetSessionClientName");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemotePlay_GetSessionClientName");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemotePlay_GetSessionCount");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemotePlay_GetSessionCount");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemotePlay_GetSessionID");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemotePlay_GetSessionID");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemotePlay_GetSessionSteamID");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemotePlay_GetSessionSteamID");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemotePlay_SetMouseCursor");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemotePlay_SetMouseCursor");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemotePlay_SetMousePosition");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemotePlay_SetMousePosition");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemotePlay_SetMouseVisibility");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemotePlay_SetMouseVisibility");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemotePlay_ShowRemotePlayTogetherUI");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemotePlay_ShowRemotePlayTogetherUI");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_BeginFileWriteBatch");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_BeginFileWriteBatch");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_CommitPublishedFileUpdate");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_CommitPublishedFileUpdate");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_CreatePublishedFileUpdateRequest");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_CreatePublishedFileUpdateRequest");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_DeletePublishedFile");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_DeletePublishedFile");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_EndFileWriteBatch");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_EndFileWriteBatch");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_EnumeratePublishedFilesByUserAction");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_EnumeratePublishedFilesByUserAction");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_EnumeratePublishedWorkshopFiles");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_EnumeratePublishedWorkshopFiles");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_EnumerateUserPublishedFiles");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_EnumerateUserPublishedFiles");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_EnumerateUserSharedWorkshopFiles");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_EnumerateUserSharedWorkshopFiles");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_EnumerateUserSubscribedFiles");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_EnumerateUserSubscribedFiles");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_FileDelete");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_FileDelete");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_FileExists");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_FileExists");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_FileForget");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_FileForget");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_FilePersisted");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_FilePersisted");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_FileRead");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_FileRead");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_FileReadAsync");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_FileReadAsync");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_FileReadAsyncComplete");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_FileReadAsyncComplete");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_FileShare");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_FileShare");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_FileWrite");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_FileWrite");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_FileWriteAsync");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_FileWriteAsync");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_FileWriteStreamCancel");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_FileWriteStreamCancel");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_FileWriteStreamClose");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_FileWriteStreamClose");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_FileWriteStreamOpen");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_FileWriteStreamOpen");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_FileWriteStreamWriteChunk");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_FileWriteStreamWriteChunk");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_GetCachedUGCCount");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_GetCachedUGCCount");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_GetCachedUGCHandle");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_GetCachedUGCHandle");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_GetFileCount");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_GetFileCount");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_GetFileNameAndSize");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_GetFileNameAndSize");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_GetFileSize");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_GetFileSize");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_GetFileTimestamp");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_GetFileTimestamp");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_GetLocalFileChange");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_GetLocalFileChange");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_GetLocalFileChangeCount");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_GetLocalFileChangeCount");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_GetPublishedFileDetails");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_GetPublishedFileDetails");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_GetPublishedItemVoteDetails");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_GetPublishedItemVoteDetails");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_GetQuota");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_GetQuota");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_GetSyncPlatforms");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_GetSyncPlatforms");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_GetUGCDetails");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_GetUGCDetails");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_GetUGCDownloadProgress");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_GetUGCDownloadProgress");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_GetUserPublishedItemVoteDetails");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_GetUserPublishedItemVoteDetails");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_IsCloudEnabledForAccount");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_IsCloudEnabledForAccount");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_IsCloudEnabledForApp");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_IsCloudEnabledForApp");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_PublishVideo");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_PublishVideo");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_PublishWorkshopFile");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_PublishWorkshopFile");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_SetCloudEnabledForApp");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_SetCloudEnabledForApp");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_SetSyncPlatforms");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_SetSyncPlatforms");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_SetUserPublishedFileAction");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_SetUserPublishedFileAction");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_SubscribePublishedFile");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_SubscribePublishedFile");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_UGCDownload");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_UGCDownload");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_UGCDownloadToLocation");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_UGCDownloadToLocation");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_UGCRead");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_UGCRead");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_UnsubscribePublishedFile");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_UnsubscribePublishedFile");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_UpdatePublishedFileDescription");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_UpdatePublishedFileDescription");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_UpdatePublishedFileFile");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_UpdatePublishedFileFile");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_UpdatePublishedFilePreviewFile");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_UpdatePublishedFilePreviewFile");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_UpdatePublishedFileSetChangeDescription");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_UpdatePublishedFileSetChangeDescription");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_UpdatePublishedFileTags");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_UpdatePublishedFileTags");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_UpdatePublishedFileTitle");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_UpdatePublishedFileTitle");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_UpdatePublishedFileVisibility");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_UpdatePublishedFileVisibility");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamRemoteStorage_UpdateUserPublishedItemVote");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamRemoteStorage_UpdateUserPublishedItemVote");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamScreenshots_AddScreenshotToLibrary");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamScreenshots_AddScreenshotToLibrary");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamScreenshots_AddVRScreenshotToLibrary");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamScreenshots_AddVRScreenshotToLibrary");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamScreenshots_HookScreenshots");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamScreenshots_HookScreenshots");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamScreenshots_IsScreenshotsHooked");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamScreenshots_IsScreenshotsHooked");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamScreenshots_SetLocation");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamScreenshots_SetLocation");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamScreenshots_TagPublishedFile");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamScreenshots_TagPublishedFile");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamScreenshots_TagUser");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamScreenshots_TagUser");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamScreenshots_TriggerScreenshot");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamScreenshots_TriggerScreenshot");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamScreenshots_WriteScreenshot");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamScreenshots_WriteScreenshot");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamTV_AddBroadcastGameData");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamTV_AddBroadcastGameData");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamTV_AddRegion");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamTV_AddRegion");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamTV_AddTimelineMarker");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamTV_AddTimelineMarker");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamTV_IsBroadcasting");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamTV_IsBroadcasting");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamTV_RemoveBroadcastGameData");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamTV_RemoveBroadcastGameData");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamTV_RemoveRegion");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamTV_RemoveRegion");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamTV_RemoveTimelineMarker");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamTV_RemoveTimelineMarker");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamTimeline_AddGamePhaseTag");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamTimeline_AddGamePhaseTag");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamTimeline_AddInstantaneousTimelineEvent");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamTimeline_AddInstantaneousTimelineEvent");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamTimeline_AddRangeTimelineEvent");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamTimeline_AddRangeTimelineEvent");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamTimeline_AddTimelineEvent");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamTimeline_AddTimelineEvent");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamTimeline_ClearTimelineStateDescription");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamTimeline_ClearTimelineStateDescription");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamTimeline_ClearTimelineTooltip");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamTimeline_ClearTimelineTooltip");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamTimeline_DoesEventRecordingExist");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamTimeline_DoesEventRecordingExist");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamTimeline_DoesGamePhaseRecordingExist");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamTimeline_DoesGamePhaseRecordingExist");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamTimeline_EndGamePhase");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamTimeline_EndGamePhase");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamTimeline_EndRangeTimelineEvent");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamTimeline_EndRangeTimelineEvent");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamTimeline_OpenOverlayToGamePhase");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamTimeline_OpenOverlayToGamePhase");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamTimeline_OpenOverlayToTimelineEvent");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamTimeline_OpenOverlayToTimelineEvent");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamTimeline_RemoveTimelineEvent");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamTimeline_RemoveTimelineEvent");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamTimeline_SetGamePhaseAttribute");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamTimeline_SetGamePhaseAttribute");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamTimeline_SetGamePhaseID");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamTimeline_SetGamePhaseID");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamTimeline_SetTimelineGameMode");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamTimeline_SetTimelineGameMode");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamTimeline_SetTimelineStateDescription");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamTimeline_SetTimelineStateDescription");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamTimeline_SetTimelineTooltip");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamTimeline_SetTimelineTooltip");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamTimeline_StartGamePhase");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamTimeline_StartGamePhase");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamTimeline_StartRangeTimelineEvent");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamTimeline_StartRangeTimelineEvent");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamTimeline_UpdateRangeTimelineEvent");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamTimeline_UpdateRangeTimelineEvent");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_AddAppDependency");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_AddAppDependency");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_AddContentDescriptor");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_AddContentDescriptor");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_AddDependency");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_AddDependency");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_AddExcludedTag");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_AddExcludedTag");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_AddItemKeyValueTag");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_AddItemKeyValueTag");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_AddItemPreviewFile");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_AddItemPreviewFile");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_AddItemPreviewVideo");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_AddItemPreviewVideo");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_AddItemToFavorites");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_AddItemToFavorites");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_AddRequiredKeyValueTag");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_AddRequiredKeyValueTag");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_AddRequiredTag");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_AddRequiredTag");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_AddRequiredTagGroup");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_AddRequiredTagGroup");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_BInitWorkshopForGameServer");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_BInitWorkshopForGameServer");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_CreateItem");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_CreateItem");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_CreateQueryAllUGCRequest");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_CreateQueryAllUGCRequest");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_CreateQueryAllUGCRequest0");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_CreateQueryAllUGCRequest0");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_CreateQueryAllUGCRequestCursor");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_CreateQueryAllUGCRequestCursor");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_CreateQueryAllUGCRequestPage");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_CreateQueryAllUGCRequestPage");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_CreateQueryUGCDetailsRequest");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_CreateQueryUGCDetailsRequest");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_CreateQueryUserUGCRequest");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_CreateQueryUserUGCRequest");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_DeleteItem");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_DeleteItem");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_DownloadItem");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_DownloadItem");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_GetAppDependencies");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_GetAppDependencies");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_GetItemDownloadInfo");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_GetItemDownloadInfo");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_GetItemInstallInfo");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_GetItemInstallInfo");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_GetItemState");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_GetItemState");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_GetItemUpdateProgress");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_GetItemUpdateProgress");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_GetNumSubscribedItems");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_GetNumSubscribedItems");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_GetNumSupportedGameVersions");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_GetNumSupportedGameVersions");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_GetQueryFirstUGCKeyValueTag");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_GetQueryFirstUGCKeyValueTag");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_GetQueryUGCAdditionalPreview");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_GetQueryUGCAdditionalPreview");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_GetQueryUGCChildren");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_GetQueryUGCChildren");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_GetQueryUGCContentDescriptors");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_GetQueryUGCContentDescriptors");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_GetQueryUGCKeyValueTag");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_GetQueryUGCKeyValueTag");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_GetQueryUGCKeyValueTag0");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_GetQueryUGCKeyValueTag0");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_GetQueryUGCMetadata");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_GetQueryUGCMetadata");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_GetQueryUGCNumAdditionalPreviews");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_GetQueryUGCNumAdditionalPreviews");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_GetQueryUGCNumKeyValueTags");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_GetQueryUGCNumKeyValueTags");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_GetQueryUGCNumTags");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_GetQueryUGCNumTags");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_GetQueryUGCPreviewURL");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_GetQueryUGCPreviewURL");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_GetQueryUGCResult");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_GetQueryUGCResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_GetQueryUGCStatistic");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_GetQueryUGCStatistic");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_GetQueryUGCTag");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_GetQueryUGCTag");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_GetQueryUGCTagDisplayName");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_GetQueryUGCTagDisplayName");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_GetSubscribedItems");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_GetSubscribedItems");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_GetSupportedGameVersionData");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_GetSupportedGameVersionData");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_GetUserContentDescriptorPreferences");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_GetUserContentDescriptorPreferences");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_GetUserItemVote");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_GetUserItemVote");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_GetWorkshopEULAStatus");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_GetWorkshopEULAStatus");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_ReleaseQueryUGCRequest");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_ReleaseQueryUGCRequest");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_RemoveAllItemKeyValueTags");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_RemoveAllItemKeyValueTags");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_RemoveAppDependency");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_RemoveAppDependency");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_RemoveContentDescriptor");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_RemoveContentDescriptor");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_RemoveDependency");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_RemoveDependency");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_RemoveItemFromFavorites");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_RemoveItemFromFavorites");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_RemoveItemKeyValueTags");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_RemoveItemKeyValueTags");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_RemoveItemPreview");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_RemoveItemPreview");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_RequestUGCDetails");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_RequestUGCDetails");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SendQueryUGCRequest");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SendQueryUGCRequest");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SetAdminQuery");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SetAdminQuery");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SetAllowCachedResponse");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SetAllowCachedResponse");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SetAllowLegacyUpload");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SetAllowLegacyUpload");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SetCloudFileNameFilter");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SetCloudFileNameFilter");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SetItemContent");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SetItemContent");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SetItemDescription");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SetItemDescription");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SetItemMetadata");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SetItemMetadata");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SetItemPreview");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SetItemPreview");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SetItemTags");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SetItemTags");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SetItemTitle");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SetItemTitle");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SetItemUpdateLanguage");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SetItemUpdateLanguage");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SetItemVisibility");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SetItemVisibility");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SetItemsDisabledLocally");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SetItemsDisabledLocally");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SetLanguage");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SetLanguage");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SetMatchAnyTag");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SetMatchAnyTag");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SetRankedByTrendDays");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SetRankedByTrendDays");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SetRequiredGameVersions");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SetRequiredGameVersions");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SetReturnAdditionalPreviews");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SetReturnAdditionalPreviews");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SetReturnChildren");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SetReturnChildren");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SetReturnKeyValueTags");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SetReturnKeyValueTags");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SetReturnLongDescription");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SetReturnLongDescription");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SetReturnMetadata");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SetReturnMetadata");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SetReturnOnlyIDs");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SetReturnOnlyIDs");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SetReturnPlaytimeStats");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SetReturnPlaytimeStats");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SetReturnTotalOnly");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SetReturnTotalOnly");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SetSearchText");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SetSearchText");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SetSubscriptionsLoadOrder");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SetSubscriptionsLoadOrder");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SetTimeCreatedDateRange");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SetTimeCreatedDateRange");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SetTimeUpdatedDateRange");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SetTimeUpdatedDateRange");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SetUserItemVote");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SetUserItemVote");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_ShowWorkshopEULA");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_ShowWorkshopEULA");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_StartItemUpdate");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_StartItemUpdate");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_StartPlaytimeTracking");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_StartPlaytimeTracking");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_StopPlaytimeTracking");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_StopPlaytimeTracking");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_StopPlaytimeTrackingForAllItems");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_StopPlaytimeTrackingForAllItems");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SubmitItemUpdate");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SubmitItemUpdate");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SubscribeItem");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SubscribeItem");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_SuspendDownloads");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_SuspendDownloads");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_UnsubscribeItem");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_UnsubscribeItem");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_UpdateItemPreviewFile");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_UpdateItemPreviewFile");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUGC_UpdateItemPreviewVideo");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUGC_UpdateItemPreviewVideo");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUnifiedMessages_GetMethodResponseData");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUnifiedMessages_GetMethodResponseData");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUnifiedMessages_GetMethodResponseInfo");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUnifiedMessages_GetMethodResponseInfo");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUnifiedMessages_ReleaseMethod");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUnifiedMessages_ReleaseMethod");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUnifiedMessages_SendMethod");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUnifiedMessages_SendMethod");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUnifiedMessages_SendNotification");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUnifiedMessages_SendNotification");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_AttachLeaderboardUGC");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_AttachLeaderboardUGC");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_ClearAchievement");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_ClearAchievement");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_DownloadLeaderboardEntries");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_DownloadLeaderboardEntries");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_DownloadLeaderboardEntriesForUsers");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_DownloadLeaderboardEntriesForUsers");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_FindLeaderboard");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_FindLeaderboard");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_FindOrCreateLeaderboard");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_FindOrCreateLeaderboard");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetAchievement");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetAchievement");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetAchievementAchievedPercent");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetAchievementAchievedPercent");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetAchievementAndUnlockTime");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetAchievementAndUnlockTime");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetAchievementDisplayAttribute");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetAchievementDisplayAttribute");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetAchievementIcon");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetAchievementIcon");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetAchievementName");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetAchievementName");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetAchievementProgressLimitsFloat");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetAchievementProgressLimitsFloat");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetAchievementProgressLimitsInt32");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetAchievementProgressLimitsInt32");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetDownloadedLeaderboardEntry");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetDownloadedLeaderboardEntry");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetGlobalStat");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetGlobalStat");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetGlobalStat0");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetGlobalStat0");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetGlobalStatDouble");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetGlobalStatDouble");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetGlobalStatHistory");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetGlobalStatHistory");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetGlobalStatHistory0");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetGlobalStatHistory0");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetGlobalStatHistoryDouble");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetGlobalStatHistoryDouble");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetGlobalStatHistoryInt64");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetGlobalStatHistoryInt64");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetGlobalStatInt64");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetGlobalStatInt64");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetLeaderboardDisplayType");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetLeaderboardDisplayType");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetLeaderboardEntryCount");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetLeaderboardEntryCount");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetLeaderboardName");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetLeaderboardName");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetLeaderboardSortMethod");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetLeaderboardSortMethod");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetMostAchievedAchievementInfo");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetMostAchievedAchievementInfo");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetNextMostAchievedAchievementInfo");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetNextMostAchievedAchievementInfo");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetNumAchievements");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetNumAchievements");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetNumberOfCurrentPlayers");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetNumberOfCurrentPlayers");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetStat");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetStat");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetStat0");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetStat0");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetStatFloat");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetStatFloat");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetStatInt32");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetStatInt32");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetUserAchievement");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetUserAchievement");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetUserAchievementAndUnlockTime");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetUserAchievementAndUnlockTime");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetUserStat");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetUserStat");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetUserStat0");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetUserStat0");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetUserStatFloat");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetUserStatFloat");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_GetUserStatInt32");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_GetUserStatInt32");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_IndicateAchievementProgress");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_IndicateAchievementProgress");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_RequestCurrentStats");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_RequestCurrentStats");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_RequestGlobalAchievementPercentages");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_RequestGlobalAchievementPercentages");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_RequestGlobalStats");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_RequestGlobalStats");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_RequestUserStats");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_RequestUserStats");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_ResetAllStats");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_ResetAllStats");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_SetAchievement");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_SetAchievement");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_SetStat");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_SetStat");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_SetStat0");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_SetStat0");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_SetStatFloat");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_SetStatFloat");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_SetStatInt32");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_SetStatInt32");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_StoreStats");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_StoreStats");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_UpdateAvgRateStat");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_UpdateAvgRateStat");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUserStats_UploadLeaderboardScore");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUserStats_UploadLeaderboardScore");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_AdvertiseGame");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_AdvertiseGame");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_BIsBehindNAT");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_BIsBehindNAT");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_BIsPhoneIdentifying");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_BIsPhoneIdentifying");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_BIsPhoneRequiringVerification");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_BIsPhoneRequiringVerification");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_BIsPhoneVerified");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_BIsPhoneVerified");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_BIsTwoFactorEnabled");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_BIsTwoFactorEnabled");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_BLoggedOn");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_BLoggedOn");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_BSetDurationControlOnlineState");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_BSetDurationControlOnlineState");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_BeginAuthSession");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_BeginAuthSession");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_CancelAuthTicket");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_CancelAuthTicket");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_DecompressVoice");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_DecompressVoice");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_EndAuthSession");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_EndAuthSession");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_GetAuthSessionTicket");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_GetAuthSessionTicket");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_GetAuthTicketForWebApi");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_GetAuthTicketForWebApi");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_GetAvailableVoice");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_GetAvailableVoice");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_GetDurationControl");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_GetDurationControl");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_GetEncryptedAppTicket");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_GetEncryptedAppTicket");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_GetGameBadgeLevel");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_GetGameBadgeLevel");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_GetHSteamUser");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_GetHSteamUser");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_GetMarketEligibility");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_GetMarketEligibility");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_GetPlayerSteamLevel");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_GetPlayerSteamLevel");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_GetSteamID");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_GetSteamID");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_GetUserDataFolder");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_GetUserDataFolder");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_GetVoice");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_GetVoice");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_GetVoiceOptimalSampleRate");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_GetVoiceOptimalSampleRate");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_InitiateGameConnection");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_InitiateGameConnection");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_InitiateGameConnection_DEPRECATED");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_InitiateGameConnection_DEPRECATED");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_RequestEncryptedAppTicket");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_RequestEncryptedAppTicket");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_RequestStoreAuthURL");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_RequestStoreAuthURL");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_StartVoiceRecording");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_StartVoiceRecording");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_StopVoiceRecording");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_StopVoiceRecording");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_TerminateGameConnection");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_TerminateGameConnection");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_TerminateGameConnection_DEPRECATED");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_TerminateGameConnection_DEPRECATED");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_TrackAppUsageEvent");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_TrackAppUsageEvent");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUser_UserHasLicenseForApp");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUser_UserHasLicenseForApp");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_BOverlayNeedsPresent");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_BOverlayNeedsPresent");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_CheckFileSignature");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_CheckFileSignature");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_DismissFloatingGamepadTextInput");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_DismissFloatingGamepadTextInput");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_DismissGamepadTextInput");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_DismissGamepadTextInput");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_FilterText");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_FilterText");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_GetAPICallFailureReason");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_GetAPICallFailureReason");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_GetAPICallResult");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_GetAPICallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_GetAppID");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_GetAppID");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_GetCSERIPPort");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_GetCSERIPPort");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_GetConnectedUniverse");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_GetConnectedUniverse");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_GetCurrentBatteryPower");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_GetCurrentBatteryPower");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_GetEnteredGamepadTextInput");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_GetEnteredGamepadTextInput");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_GetEnteredGamepadTextLength");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_GetEnteredGamepadTextLength");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_GetIPCCallCount");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_GetIPCCallCount");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_GetIPCountry");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_GetIPCountry");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_GetIPv6ConnectivityState");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_GetIPv6ConnectivityState");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_GetImageRGBA");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_GetImageRGBA");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_GetImageSize");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_GetImageSize");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_GetSecondsSinceAppActive");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_GetSecondsSinceAppActive");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_GetSecondsSinceComputerActive");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_GetSecondsSinceComputerActive");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_GetServerRealTime");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_GetServerRealTime");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_GetSteamUILanguage");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_GetSteamUILanguage");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_InitFilterText");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_InitFilterText");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_IsAPICallCompleted");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_IsAPICallCompleted");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_IsOverlayEnabled");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_IsOverlayEnabled");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_IsSteamChinaLauncher");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_IsSteamChinaLauncher");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_IsSteamInBigPictureMode");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_IsSteamInBigPictureMode");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_IsSteamRunningInVR");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_IsSteamRunningInVR");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_IsSteamRunningOnSteamDeck");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_IsSteamRunningOnSteamDeck");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_IsVRHeadsetStreamingEnabled");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_IsVRHeadsetStreamingEnabled");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_RunFrame");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_RunFrame");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_SetGameLauncherMode");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_SetGameLauncherMode");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_SetOverlayNotificationInset");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_SetOverlayNotificationInset");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_SetOverlayNotificationPosition");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_SetOverlayNotificationPosition");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_SetVRHeadsetStreamingEnabled");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_SetVRHeadsetStreamingEnabled");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_SetWarningMessageHook");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_SetWarningMessageHook");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_ShowFloatingGamepadTextInput");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_ShowFloatingGamepadTextInput");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_ShowGamepadTextInput");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_ShowGamepadTextInput");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_ShowModalGamepadTextInput");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_ShowModalGamepadTextInput");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamUtils_StartVRDashboard");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamUtils_StartVRDashboard");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamVideo_AddTimelineHighlightMarker");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamVideo_AddTimelineHighlightMarker");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamVideo_AddTimelineRange");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamVideo_AddTimelineRange");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamVideo_AddTimelineRangeEnd");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamVideo_AddTimelineRangeEnd");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamVideo_AddTimelineRangeStart");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamVideo_AddTimelineRangeStart");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamVideo_AddTimelineTimestamp");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamVideo_AddTimelineTimestamp");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamVideo_GetOPFSettings");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamVideo_GetOPFSettings");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamVideo_GetOPFStringForApp");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamVideo_GetOPFStringForApp");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamVideo_GetVideoURL");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamVideo_GetVideoURL");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamVideo_IsBroadcasting");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamVideo_IsBroadcasting");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ISteamVideo_SetTimelineGameMode");
        src_address = dlsym(original_lib_handle, "SteamAPI_ISteamVideo_SetTimelineGameMode");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_Init");
        src_address = dlsym(original_lib_handle, "SteamAPI_Init");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_InitAnonymousUser");
        src_address = dlsym(original_lib_handle, "SteamAPI_InitAnonymousUser");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_InitFlat");
        src_address = dlsym(original_lib_handle, "SteamAPI_InitFlat");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_InitSafe");
        src_address = dlsym(original_lib_handle, "SteamAPI_InitSafe");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_IsSteamRunning");
        src_address = dlsym(original_lib_handle, "SteamAPI_IsSteamRunning");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ManualDispatch_FreeLastCallback");
        src_address = dlsym(original_lib_handle, "SteamAPI_ManualDispatch_FreeLastCallback");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ManualDispatch_GetAPICallResult");
        src_address = dlsym(original_lib_handle, "SteamAPI_ManualDispatch_GetAPICallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ManualDispatch_GetNextCallback");
        src_address = dlsym(original_lib_handle, "SteamAPI_ManualDispatch_GetNextCallback");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ManualDispatch_Init");
        src_address = dlsym(original_lib_handle, "SteamAPI_ManualDispatch_Init");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ManualDispatch_RunFrame");
        src_address = dlsym(original_lib_handle, "SteamAPI_ManualDispatch_RunFrame");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_MatchMakingKeyValuePair_t_Construct");
        src_address = dlsym(original_lib_handle, "SteamAPI_MatchMakingKeyValuePair_t_Construct");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_RegisterCallResult");
        src_address = dlsym(original_lib_handle, "SteamAPI_RegisterCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_RegisterCallback");
        src_address = dlsym(original_lib_handle, "SteamAPI_RegisterCallback");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_ReleaseCurrentThreadMemory");
        src_address = dlsym(original_lib_handle, "SteamAPI_ReleaseCurrentThreadMemory");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_RestartAppIfNecessary");
        src_address = dlsym(original_lib_handle, "SteamAPI_RestartAppIfNecessary");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_RunCallbacks");
        src_address = dlsym(original_lib_handle, "SteamAPI_RunCallbacks");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SetBreakpadAppID");
        src_address = dlsym(original_lib_handle, "SteamAPI_SetBreakpadAppID");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SetMiniDumpComment");
        src_address = dlsym(original_lib_handle, "SteamAPI_SetMiniDumpComment");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SetTryCatchCallbacks");
        src_address = dlsym(original_lib_handle, "SteamAPI_SetTryCatchCallbacks");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_Shutdown");
        src_address = dlsym(original_lib_handle, "SteamAPI_Shutdown");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamAppList_v001");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamAppList_v001");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamApps_v008");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamApps_v008");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamController_v007");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamController_v007");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamController_v008");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamController_v008");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamDatagramHostedAddress_Clear");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamDatagramHostedAddress_Clear");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamDatagramHostedAddress_GetPopID");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamDatagramHostedAddress_GetPopID");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamDatagramHostedAddress_SetDevAddress");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamDatagramHostedAddress_SetDevAddress");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamFriends_v017");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamFriends_v017");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamFriends_v018");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamFriends_v018");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamGameSearch_v001");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamGameSearch_v001");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamGameServerApps_v008");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamGameServerApps_v008");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamGameServerHTTP_v003");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamGameServerHTTP_v003");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamGameServerInventory_v003");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamGameServerInventory_v003");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamGameServerNetworkingMessages_SteamAPI_v002");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamGameServerNetworkingMessages_SteamAPI_v002");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamGameServerNetworkingMessages_v002");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamGameServerNetworkingMessages_v002");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamGameServerNetworkingSockets_SteamAPI_v009");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamGameServerNetworkingSockets_SteamAPI_v009");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamGameServerNetworkingSockets_SteamAPI_v011");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamGameServerNetworkingSockets_SteamAPI_v011");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamGameServerNetworkingSockets_SteamAPI_v012");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamGameServerNetworkingSockets_SteamAPI_v012");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamGameServerNetworkingSockets_v008");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamGameServerNetworkingSockets_v008");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamGameServerNetworkingSockets_v009");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamGameServerNetworkingSockets_v009");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamGameServerNetworking_v006");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamGameServerNetworking_v006");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamGameServerStats_v001");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamGameServerStats_v001");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamGameServerUGC_v014");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamGameServerUGC_v014");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamGameServerUGC_v015");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamGameServerUGC_v015");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamGameServerUGC_v016");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamGameServerUGC_v016");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamGameServerUGC_v017");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamGameServerUGC_v017");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamGameServerUGC_v018");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamGameServerUGC_v018");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamGameServerUGC_v020");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamGameServerUGC_v020");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamGameServerUGC_v021");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamGameServerUGC_v021");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamGameServerUtils_v009");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamGameServerUtils_v009");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamGameServerUtils_v010");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamGameServerUtils_v010");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamGameServer_v013");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamGameServer_v013");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamGameServer_v014");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamGameServer_v014");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamGameServer_v015");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamGameServer_v015");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamHTMLSurface_v005");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamHTMLSurface_v005");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamHTTP_v003");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamHTTP_v003");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamIPAddress_t_IsSet");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamIPAddress_t_IsSet");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamInput_v001");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamInput_v001");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamInput_v002");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamInput_v002");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamInput_v005");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamInput_v005");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamInput_v006");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamInput_v006");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamInventory_v003");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamInventory_v003");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamMatchmakingServers_v002");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamMatchmakingServers_v002");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamMatchmaking_v009");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamMatchmaking_v009");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamMusicRemote_v001");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamMusicRemote_v001");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamMusic_v001");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamMusic_v001");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingConfigValue_t_SetFloat");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingConfigValue_t_SetFloat");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingConfigValue_t_SetInt32");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingConfigValue_t_SetInt32");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingConfigValue_t_SetInt64");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingConfigValue_t_SetInt64");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingConfigValue_t_SetPtr");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingConfigValue_t_SetPtr");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingConfigValue_t_SetString");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingConfigValue_t_SetString");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIPAddrRender_c_str");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIPAddrRender_c_str");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIPAddr_Clear");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIPAddr_Clear");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIPAddr_GetFakeIPType");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIPAddr_GetFakeIPType");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIPAddr_GetIPv4");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIPAddr_GetIPv4");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIPAddr_IsEqualTo");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIPAddr_IsEqualTo");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIPAddr_IsFakeIP");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIPAddr_IsFakeIP");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIPAddr_IsIPv4");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIPAddr_IsIPv4");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIPAddr_IsIPv6AllZeros");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIPAddr_IsIPv6AllZeros");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIPAddr_IsLocalHost");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIPAddr_IsLocalHost");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIPAddr_ParseString");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIPAddr_ParseString");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIPAddr_SetIPv4");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIPAddr_SetIPv4");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIPAddr_SetIPv6");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIPAddr_SetIPv6");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIPAddr_SetIPv6LocalHost");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIPAddr_SetIPv6LocalHost");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIPAddr_ToString");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIPAddr_ToString");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIdentityRender_c_str");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIdentityRender_c_str");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIdentity_Clear");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIdentity_Clear");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIdentity_GetFakeIPType");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIdentity_GetFakeIPType");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIdentity_GetGenericBytes");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIdentity_GetGenericBytes");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIdentity_GetGenericString");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIdentity_GetGenericString");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIdentity_GetIPAddr");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIdentity_GetIPAddr");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIdentity_GetIPv4");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIdentity_GetIPv4");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIdentity_GetPSNID");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIdentity_GetPSNID");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIdentity_GetStadiaID");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIdentity_GetStadiaID");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIdentity_GetSteamID");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIdentity_GetSteamID");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIdentity_GetSteamID64");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIdentity_GetSteamID64");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIdentity_GetXboxPairwiseID");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIdentity_GetXboxPairwiseID");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIdentity_IsEqualTo");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIdentity_IsEqualTo");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIdentity_IsFakeIP");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIdentity_IsFakeIP");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIdentity_IsInvalid");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIdentity_IsInvalid");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIdentity_IsLocalHost");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIdentity_IsLocalHost");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIdentity_ParseString");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIdentity_ParseString");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIdentity_SetGenericBytes");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIdentity_SetGenericBytes");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIdentity_SetGenericString");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIdentity_SetGenericString");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIdentity_SetIPAddr");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIdentity_SetIPAddr");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIdentity_SetIPv4Addr");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIdentity_SetIPv4Addr");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIdentity_SetLocalHost");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIdentity_SetLocalHost");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIdentity_SetPSNID");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIdentity_SetPSNID");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIdentity_SetStadiaID");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIdentity_SetStadiaID");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIdentity_SetSteamID");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIdentity_SetSteamID");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIdentity_SetSteamID64");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIdentity_SetSteamID64");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIdentity_SetXboxPairwiseID");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIdentity_SetXboxPairwiseID");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingIdentity_ToString");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingIdentity_ToString");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingMessage_t_Release");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingMessage_t_Release");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingMessages_SteamAPI_v002");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingMessages_SteamAPI_v002");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingMessages_v002");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingMessages_v002");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingPOPIDRender_c_str");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingPOPIDRender_c_str");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingSockets_SteamAPI_v009");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingSockets_SteamAPI_v009");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingSockets_SteamAPI_v011");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingSockets_SteamAPI_v011");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingSockets_SteamAPI_v012");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingSockets_SteamAPI_v012");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingSockets_v008");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingSockets_v008");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingSockets_v009");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingSockets_v009");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingUtils_SteamAPI_v003");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingUtils_SteamAPI_v003");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingUtils_SteamAPI_v004");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingUtils_SteamAPI_v004");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworkingUtils_v003");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworkingUtils_v003");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamNetworking_v006");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamNetworking_v006");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamParentalSettings_v001");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamParentalSettings_v001");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamParties_v002");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamParties_v002");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamRemotePlay_v001");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamRemotePlay_v001");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamRemotePlay_v002");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamRemotePlay_v002");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamRemotePlay_v003");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamRemotePlay_v003");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamRemoteStorage_v014");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamRemoteStorage_v014");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamRemoteStorage_v016");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamRemoteStorage_v016");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamScreenshots_v003");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamScreenshots_v003");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamTV_v001");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamTV_v001");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamTimeline_v001");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamTimeline_v001");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamTimeline_v004");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamTimeline_v004");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamUGC_v014");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamUGC_v014");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamUGC_v015");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamUGC_v015");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamUGC_v016");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamUGC_v016");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamUGC_v017");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamUGC_v017");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamUGC_v018");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamUGC_v018");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamUGC_v020");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamUGC_v020");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamUGC_v021");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamUGC_v021");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamUserStats_v011");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamUserStats_v011");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamUserStats_v012");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamUserStats_v012");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamUserStats_v013");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamUserStats_v013");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamUser_v020");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamUser_v020");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamUser_v021");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamUser_v021");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamUser_v022");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamUser_v022");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamUser_v023");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamUser_v023");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamUtils_v009");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamUtils_v009");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamUtils_v010");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamUtils_v010");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamVideo_v002");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamVideo_v002");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamVideo_v003");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamVideo_v003");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamVideo_v004");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamVideo_v004");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_SteamVideo_v007");
        src_address = dlsym(original_lib_handle, "SteamAPI_SteamVideo_v007");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_UnregisterCallResult");
        src_address = dlsym(original_lib_handle, "SteamAPI_UnregisterCallResult");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_UnregisterCallback");
        src_address = dlsym(original_lib_handle, "SteamAPI_UnregisterCallback");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_UseBreakpadCrashHandler");
        src_address = dlsym(original_lib_handle, "SteamAPI_UseBreakpadCrashHandler");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_WriteMiniDump");
        src_address = dlsym(original_lib_handle, "SteamAPI_WriteMiniDump");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_gameserveritem_t_Construct");
        src_address = dlsym(original_lib_handle, "SteamAPI_gameserveritem_t_Construct");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_gameserveritem_t_GetName");
        src_address = dlsym(original_lib_handle, "SteamAPI_gameserveritem_t_GetName");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_gameserveritem_t_SetName");
        src_address = dlsym(original_lib_handle, "SteamAPI_gameserveritem_t_SetName");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_servernetadr_t_Assign");
        src_address = dlsym(original_lib_handle, "SteamAPI_servernetadr_t_Assign");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_servernetadr_t_Construct");
        src_address = dlsym(original_lib_handle, "SteamAPI_servernetadr_t_Construct");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_servernetadr_t_GetConnectionAddressString");
        src_address = dlsym(original_lib_handle, "SteamAPI_servernetadr_t_GetConnectionAddressString");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_servernetadr_t_GetConnectionPort");
        src_address = dlsym(original_lib_handle, "SteamAPI_servernetadr_t_GetConnectionPort");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_servernetadr_t_GetIP");
        src_address = dlsym(original_lib_handle, "SteamAPI_servernetadr_t_GetIP");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_servernetadr_t_GetQueryAddressString");
        src_address = dlsym(original_lib_handle, "SteamAPI_servernetadr_t_GetQueryAddressString");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_servernetadr_t_GetQueryPort");
        src_address = dlsym(original_lib_handle, "SteamAPI_servernetadr_t_GetQueryPort");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_servernetadr_t_Init");
        src_address = dlsym(original_lib_handle, "SteamAPI_servernetadr_t_Init");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_servernetadr_t_IsLessThan");
        src_address = dlsym(original_lib_handle, "SteamAPI_servernetadr_t_IsLessThan");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_servernetadr_t_SetConnectionPort");
        src_address = dlsym(original_lib_handle, "SteamAPI_servernetadr_t_SetConnectionPort");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_servernetadr_t_SetIP");
        src_address = dlsym(original_lib_handle, "SteamAPI_servernetadr_t_SetIP");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAPI_servernetadr_t_SetQueryPort");
        src_address = dlsym(original_lib_handle, "SteamAPI_servernetadr_t_SetQueryPort");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamAppList");
        src_address = dlsym(original_lib_handle, "SteamAppList");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamApps");
        src_address = dlsym(original_lib_handle, "SteamApps");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamClient");
        src_address = dlsym(original_lib_handle, "SteamClient");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamContentServer");
        src_address = dlsym(original_lib_handle, "SteamContentServer");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamContentServerUtils");
        src_address = dlsym(original_lib_handle, "SteamContentServerUtils");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamContentServer_Init");
        src_address = dlsym(original_lib_handle, "SteamContentServer_Init");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamContentServer_RunCallbacks");
        src_address = dlsym(original_lib_handle, "SteamContentServer_RunCallbacks");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamContentServer_Shutdown");
        src_address = dlsym(original_lib_handle, "SteamContentServer_Shutdown");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamController");
        src_address = dlsym(original_lib_handle, "SteamController");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamController_GetControllerState");
        src_address = dlsym(original_lib_handle, "SteamController_GetControllerState");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamController_Init");
        src_address = dlsym(original_lib_handle, "SteamController_Init");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamController_SetOverrideMode");
        src_address = dlsym(original_lib_handle, "SteamController_SetOverrideMode");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamController_Shutdown");
        src_address = dlsym(original_lib_handle, "SteamController_Shutdown");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamController_TriggerHapticPulse");
        src_address = dlsym(original_lib_handle, "SteamController_TriggerHapticPulse");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamFriends");
        src_address = dlsym(original_lib_handle, "SteamFriends");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamGameServer");
        src_address = dlsym(original_lib_handle, "SteamGameServer");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamGameServerApps");
        src_address = dlsym(original_lib_handle, "SteamGameServerApps");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamGameServerHTTP");
        src_address = dlsym(original_lib_handle, "SteamGameServerHTTP");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamGameServerInventory");
        src_address = dlsym(original_lib_handle, "SteamGameServerInventory");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamGameServerNetworking");
        src_address = dlsym(original_lib_handle, "SteamGameServerNetworking");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamGameServerStats");
        src_address = dlsym(original_lib_handle, "SteamGameServerStats");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamGameServerUGC");
        src_address = dlsym(original_lib_handle, "SteamGameServerUGC");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamGameServerUtils");
        src_address = dlsym(original_lib_handle, "SteamGameServerUtils");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamGameServer_BSecure");
        src_address = dlsym(original_lib_handle, "SteamGameServer_BSecure");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamGameServer_GetHSteamPipe");
        src_address = dlsym(original_lib_handle, "SteamGameServer_GetHSteamPipe");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamGameServer_GetHSteamUser");
        src_address = dlsym(original_lib_handle, "SteamGameServer_GetHSteamUser");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamGameServer_GetIPCCallCount");
        src_address = dlsym(original_lib_handle, "SteamGameServer_GetIPCCallCount");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamGameServer_GetSteamID");
        src_address = dlsym(original_lib_handle, "SteamGameServer_GetSteamID");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamGameServer_Init");
        src_address = dlsym(original_lib_handle, "SteamGameServer_Init");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamGameServer_InitSafe");
        src_address = dlsym(original_lib_handle, "SteamGameServer_InitSafe");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamGameServer_RunCallbacks");
        src_address = dlsym(original_lib_handle, "SteamGameServer_RunCallbacks");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamGameServer_Shutdown");
        src_address = dlsym(original_lib_handle, "SteamGameServer_Shutdown");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamHTMLSurface");
        src_address = dlsym(original_lib_handle, "SteamHTMLSurface");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamHTTP");
        src_address = dlsym(original_lib_handle, "SteamHTTP");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamInternal_ContextInit");
        src_address = dlsym(original_lib_handle, "SteamInternal_ContextInit");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamInternal_CreateInterface");
        src_address = dlsym(original_lib_handle, "SteamInternal_CreateInterface");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamInternal_FindOrCreateGameServerInterface");
        src_address = dlsym(original_lib_handle, "SteamInternal_FindOrCreateGameServerInterface");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamInternal_FindOrCreateUserInterface");
        src_address = dlsym(original_lib_handle, "SteamInternal_FindOrCreateUserInterface");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamInternal_GameServer_Init");
        src_address = dlsym(original_lib_handle, "SteamInternal_GameServer_Init");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamInternal_GameServer_Init_V2");
        src_address = dlsym(original_lib_handle, "SteamInternal_GameServer_Init_V2");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamInternal_GlobalContextGameServerPtr");
        src_address = dlsym(original_lib_handle, "SteamInternal_GlobalContextGameServerPtr");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamInternal_SteamAPI_Init");
        src_address = dlsym(original_lib_handle, "SteamInternal_SteamAPI_Init");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamInventory");
        src_address = dlsym(original_lib_handle, "SteamInventory");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamMasterServerUpdater");
        src_address = dlsym(original_lib_handle, "SteamMasterServerUpdater");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamMatchmaking");
        src_address = dlsym(original_lib_handle, "SteamMatchmaking");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamMatchmakingServers");
        src_address = dlsym(original_lib_handle, "SteamMatchmakingServers");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamMusic");
        src_address = dlsym(original_lib_handle, "SteamMusic");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamMusicRemote");
        src_address = dlsym(original_lib_handle, "SteamMusicRemote");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamNetworking");
        src_address = dlsym(original_lib_handle, "SteamNetworking");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamRealPath");
        src_address = dlsym(original_lib_handle, "SteamRealPath");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamRemoteStorage");
        src_address = dlsym(original_lib_handle, "SteamRemoteStorage");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamScreenshots");
        src_address = dlsym(original_lib_handle, "SteamScreenshots");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamUGC");
        src_address = dlsym(original_lib_handle, "SteamUGC");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamUnifiedMessages");
        src_address = dlsym(original_lib_handle, "SteamUnifiedMessages");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamUser");
        src_address = dlsym(original_lib_handle, "SteamUser");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamUserStats");
        src_address = dlsym(original_lib_handle, "SteamUserStats");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamUtils");
        src_address = dlsym(original_lib_handle, "SteamUtils");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamVR_ComputeDistortion");
        src_address = dlsym(original_lib_handle, "SteamVR_ComputeDistortion");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamVR_GetD3D9AdapterIndex");
        src_address = dlsym(original_lib_handle, "SteamVR_GetD3D9AdapterIndex");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamVR_GetDisplayId");
        src_address = dlsym(original_lib_handle, "SteamVR_GetDisplayId");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamVR_GetDriverId");
        src_address = dlsym(original_lib_handle, "SteamVR_GetDriverId");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamVR_GetEyeOutputViewport");
        src_address = dlsym(original_lib_handle, "SteamVR_GetEyeOutputViewport");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamVR_GetHeadFromEyePose");
        src_address = dlsym(original_lib_handle, "SteamVR_GetHeadFromEyePose");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamVR_GetLastTrackerFromHeadPose");
        src_address = dlsym(original_lib_handle, "SteamVR_GetLastTrackerFromHeadPose");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamVR_GetProjectionMatrix");
        src_address = dlsym(original_lib_handle, "SteamVR_GetProjectionMatrix");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamVR_GetProjectionRaw");
        src_address = dlsym(original_lib_handle, "SteamVR_GetProjectionRaw");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamVR_GetRecommendedRenderTargetSize");
        src_address = dlsym(original_lib_handle, "SteamVR_GetRecommendedRenderTargetSize");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamVR_GetTrackerFromHeadPose");
        src_address = dlsym(original_lib_handle, "SteamVR_GetTrackerFromHeadPose");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamVR_GetTrackerZeroPose");
        src_address = dlsym(original_lib_handle, "SteamVR_GetTrackerZeroPose");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamVR_GetViewMatrix");
        src_address = dlsym(original_lib_handle, "SteamVR_GetViewMatrix");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamVR_GetWindowBounds");
        src_address = dlsym(original_lib_handle, "SteamVR_GetWindowBounds");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamVR_IHmd_Version");
        src_address = dlsym(original_lib_handle, "SteamVR_IHmd_Version");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamVR_WillDriftInYaw");
        src_address = dlsym(original_lib_handle, "SteamVR_WillDriftInYaw");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamVR_ZeroTracker");
        src_address = dlsym(original_lib_handle, "SteamVR_ZeroTracker");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "SteamVideo");
        src_address = dlsym(original_lib_handle, "SteamVideo");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "Steam_BGetCallback");
        src_address = dlsym(original_lib_handle, "Steam_BGetCallback");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "Steam_FreeLastCallback");
        src_address = dlsym(original_lib_handle, "Steam_FreeLastCallback");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "Steam_GetHSteamUserCurrent");
        src_address = dlsym(original_lib_handle, "Steam_GetHSteamUserCurrent");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "Steam_RegisterInterfaceFuncs");
        src_address = dlsym(original_lib_handle, "Steam_RegisterInterfaceFuncs");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "Steam_RunCallbacks");
        src_address = dlsym(original_lib_handle, "Steam_RunCallbacks");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "VR_GetControlPanel");
        src_address = dlsym(original_lib_handle, "VR_GetControlPanel");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "VR_GetGenericInterface");
        src_address = dlsym(original_lib_handle, "VR_GetGenericInterface");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "VR_GetStringForHmdError");
        src_address = dlsym(original_lib_handle, "VR_GetStringForHmdError");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "VR_Init");
        src_address = dlsym(original_lib_handle, "VR_Init");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "VR_IsHmdPresent");
        src_address = dlsym(original_lib_handle, "VR_IsHmdPresent");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "VR_Shutdown");
        src_address = dlsym(original_lib_handle, "VR_Shutdown");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        dest_address = dlsym(self_lib_handle, "g_pSteamClientGameServer");
        src_address = dlsym(original_lib_handle, "g_pSteamClientGameServer");
        if(!src_address) src_address = reinterpret_cast<void*>(panic_exit);
        std::memcpy(static_cast<uint8_t*>(dest_address) + 1, &src_address, sizeof(void*));

        initialized = true;
        LOG_INFO("Proxy exports initialized");
    }
}
